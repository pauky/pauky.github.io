<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据库如何实现一致性"><meta name="keywords" content="read"><meta name="author" content="杨润炜"><meta name="copyright" content="杨润炜"><title>简单总结《改变未来的九大算法》（四）——数据库如何实例一致性 | Cwalker</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97%EF%BC%88%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">预写日志（待办事项）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%90%E4%B8%AA%E6%93%8D%E4%BD%9C%E4%B8%AD%E9%80%94%E5%A4%B1%E8%B4%A5%E6%80%8E%E6%A0%B7%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">事务的某个操作中途失败怎样办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">怎样实现回滚？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%9B%9E%E6%BB%9A%E6%97%B6%E4%B8%8D%E4%BC%9A%E6%8D%9F%E5%9D%8F%E7%8E%B0%E6%9C%89%E6%95%B0%E6%8D%AE%E5%91%A2%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">怎样保证回滚时不会损坏现有数据呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D%E6%97%B6%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B7%B2%E7%BB%8F%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">事务恢复时如何处理已经执行成功的操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E4%B8%80%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97%E5%A4%B1%E8%B4%A5%E6%80%8E%E6%A0%B7%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">万一预写日志失败怎样办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%9F%E5%80%9F%E9%89%B4%E4%BA%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%A2%84%E5%AE%9A%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">操作系统也借鉴了数据库的预定日志机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">为什么预写日志能实现多个操作的一致性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%88%E9%A2%84%E5%A4%87%E6%8F%90%E4%BA%A4%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">两阶段提交（预备提交）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E7%90%83%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.</span> <span class="toc-text">约球的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5%E7%BA%A6%E4%B8%AA%E7%90%83%E8%A6%81%E4%B8%A4%E6%AC%A1%E7%A1%AE%E8%AE%A4%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">为啥约个球要两次确认？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E8%A1%A8%E7%8E%B0%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">实际在数据库中是怎样的表现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">主从节点数据同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E7%9A%84redo%E4%B8%8Ebinlog"><span class="toc-number">2.2.2.</span> <span class="toc-text">mysql的redo与binlog</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6%E7%9A%84%E6%99%AE%E9%80%82%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">机制的普适性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%E9%AB%98%E6%95%88%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">最后简单说下高效性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">杨润炜</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">132</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cwalker</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">简单总结《改变未来的九大算法》（四）——数据库如何实例一致性</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/tech/"> tech</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o" aria-hidden="true"></i><a href="/a/125.html#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="a/125.html"></span></a></div><div class="article-container" id="post-content"><p>最近刚好在学习操作系统中的持久化实现，即文件系统。它与数据库的一些理念是相通的，所以将这篇算法复习一下，结合之后再总结出来。</p>
<span id="more"></span>

<p>作为一名应用开发人员，必定会接触到数据库，也一定知道数据库能够保证数据的可靠性，一致性是其中最重要的，且往往能高效地处理数据。接下来将根据《改变未来的九大算法》书中所说明的内容来进行阐述。<br>该书说明了数据库使用了两种方式来实现数据库的一致性：</p>
<ul>
<li>预写日志（待办事项）</li>
<li>两阶段提交（预备提交）</li>
</ul>
<h2 id="预写日志（待办事项）"><a href="#预写日志（待办事项）" class="headerlink" title="预写日志（待办事项）"></a>预写日志（待办事项）</h2><p>用过数据库的，肯定知道事务。我们知道它能保证多个操作是原子性的，事务的原子性是指事务中的操作全部只有两种状态，要不同时完成，要不同时失败。<br>相对预定日志，“待办事项”更能说明这一机制的工作原理。它将多个操作比作待办列表中的事项，能够记录完成状态，如果中途离开（机器宕机、数据库崩溃）也能依据该列表的信息回到之前的工作状态。</p>
<h3 id="事务的某个操作中途失败怎样办？"><a href="#事务的某个操作中途失败怎样办？" class="headerlink" title="事务的某个操作中途失败怎样办？"></a>事务的某个操作中途失败怎样办？</h3><p>有两种选择：</p>
<ul>
<li>一种是回滚，即回撤之前执行的操作</li>
<li>一种是恢复，即继续执行操作</li>
</ul>
<h3 id="怎样实现回滚？"><a href="#怎样实现回滚？" class="headerlink" title="怎样实现回滚？"></a>怎样实现回滚？</h3><p>日志里会包含操作的数据内容，只要将操作反转一下就是回滚操作了。</p>
<h3 id="怎样保证回滚时不会损坏现有数据呢？"><a href="#怎样保证回滚时不会损坏现有数据呢？" class="headerlink" title="怎样保证回滚时不会损坏现有数据呢？"></a>怎样保证回滚时不会损坏现有数据呢？</h3><p>操作前是加锁的，即在事务完成或回滚前，其它人（数据库线程、事务）是不能改动原有数据的。</p>
<h3 id="事务恢复时如何处理已经执行成功的操作？"><a href="#事务恢复时如何处理已经执行成功的操作？" class="headerlink" title="事务恢复时如何处理已经执行成功的操作？"></a>事务恢复时如何处理已经执行成功的操作？</h3><p>恢复时不需要关注已经执行成功的，只要从头开始执行一遍就行，因为操作已经保证了幂等性。<br>例如，A向B的转账200元的操作日志内容为：A的600元改为400元，B的300元改为500元。<br>这样就算同个操作执行了多次，对数据的影响是一样的。</p>
<h3 id="万一预写日志失败怎样办？"><a href="#万一预写日志失败怎样办？" class="headerlink" title="万一预写日志失败怎样办？"></a>万一预写日志失败怎样办？</h3><p>事务不会开始，所以不会怎样。</p>
<h3 id="操作系统也借鉴了数据库的预定日志机制"><a href="#操作系统也借鉴了数据库的预定日志机制" class="headerlink" title="操作系统也借鉴了数据库的预定日志机制"></a>操作系统也借鉴了数据库的预定日志机制</h3><p>预定日志这种方法，能把多个操作封装为原子操作，操作系统实现文件系统时也借鉴了此机制。<br>例如，文件系统要写入一个文件时，会涉及到多个写入IO操作：写文件数据、更新inode位图、更新数据位图，如果不完整地执行所有操作，将产生数据损坏或数据不一致的故障。<br>为了让这多个写IO变成一个原子IO操作，文件系统也引入了预定日志，先将这些IO操作通过日志记录下来，数据可以放日志，也可以不放（元数据日志方法），万一因为机器崩溃导致某些操作中途失败，在机器重启后，文件系统会根据日志继续完成，以实现数据的一致性。</p>
<h3 id="为什么预写日志能实现多个操作的一致性？"><a href="#为什么预写日志能实现多个操作的一致性？" class="headerlink" title="为什么预写日志能实现多个操作的一致性？"></a>为什么预写日志能实现多个操作的一致性？</h3><p>首先要说明预写日志也可能要多步，且可能会中途失败，所以它也要保证一致性（或者说原子操作）。<br>我先以文件系统为例来说明吧。实际写文件的一致性需要保证写文件数据、更新inode位图、更新数据位图，这里面涉及到inode位图、数据位图、数据块等不同磁盘区域，如果其中一个失败不仅当前写的文件损坏，且可能影响其它文件，而且不同区域的写协同成本更高。而预写日志可以固定在磁盘某区域，虽然日志数据可能也要分多步写入，但在文件系统中可以使用磁盘原子操作（写512字节）、写屏障、校验和的方式来保证预写日志的一致性。对于区域单一、较为独立的预写日志数据，要保证一致性比较简单。<br>数据库也是一样，如果要对某个表写入数据，首先就要定位、加锁、更新索引、写入磁盘等多个复杂IO操作，而预写日志则可以在独立的区域存储较为单一的结构，实现保证一致性较简单。</p>
<h2 id="两阶段提交（预备提交）"><a href="#两阶段提交（预备提交）" class="headerlink" title="两阶段提交（预备提交）"></a>两阶段提交（预备提交）</h2><p>数据库往往要求多副本多节点，甚至节点的异地多活，这时候怎样保证副本的数据复制的一致性呢？这就要求需要有个协同的机制，保证大家（所有节点）的数据相同。</p>
<h3 id="约球的例子"><a href="#约球的例子" class="headerlink" title="约球的例子"></a>约球的例子</h3><p>书中用了个生活的例子来解释这一机制，十分生动形象。<br>故事是这样的：</p>
<ol>
<li>周末小明想约2个朋友小智、小烈打球。</li>
<li>他先打电话给小智约今天下午4点半打球，小智说可以，小明说他跟小烈确认后再找他；</li>
<li>他打电话给小烈约今天下午4点半打球，小烈答应了，小明就跟他正式约定了。</li>
<li>他再打电话跟小智说确认4点半打球，最后他跟小智也正式确认了约定。</li>
</ol>
<h4 id="为啥约个球要两次确认？"><a href="#为啥约个球要两次确认？" class="headerlink" title="为啥约个球要两次确认？"></a>为啥约个球要两次确认？</h4><p>因为跟别人协同一致的时间点。如果要约的时间别人不同意，就得取消后再改个时间重新审议。所以过程中有个“预备”的过程，即提出打球时间（预案），然后大家确认时间OK就确认（提交），如果不OK则可能要重新开始整个过程，或者取消。<br>（有人可能要抬杠说微信多人通话，但其实都是要有个“预备”的提案，大家都确认后，再统一“提交”约定，这样也是个两阶段提交。）</p>
<h3 id="实际在数据库中是怎样的表现？"><a href="#实际在数据库中是怎样的表现？" class="headerlink" title="实际在数据库中是怎样的表现？"></a>实际在数据库中是怎样的表现？</h3><h4 id="主从节点数据同步"><a href="#主从节点数据同步" class="headerlink" title="主从节点数据同步"></a>主从节点数据同步</h4><p>还是以书中的例子来说明。<br><img src="https://img.yangrunwei.com/article-img/20220220/62923b0a-117a-476a-82f5-f9ead45db0e7--two-stage-submit.jpg" alt="two-stage-commit" title="two-stage-commit"></p>
<h4 id="mysql的redo与binlog"><a href="#mysql的redo与binlog" class="headerlink" title="mysql的redo与binlog"></a>mysql的redo与binlog</h4><p>redo和binlog都记录了数据的操作，异常中断时可以从其中一个恢复数据，即在正常动作时需要保证两者数据一致性。<br>mysql的具体实现时通过redo来协调，它有两种状态，prepare和commit。当redo记录完成时，redo状态为prepare，然后记录binlog，当binlog完成后，redo状态改为commit。这里的prepare和commit状态就对应了预备和提交的实现。</p>
<h3 id="机制的普适性"><a href="#机制的普适性" class="headerlink" title="机制的普适性"></a>机制的普适性</h3><p>对于跨系统间的数据一致性协同问题，两阶段提交是个常用的解决方案。</p>
<h2 id="最后简单说下高效性"><a href="#最后简单说下高效性" class="headerlink" title="最后简单说下高效性"></a>最后简单说下高效性</h2><p>关系数据库、虚表都是为了数据库的高效性而设计的。</p>
<ul>
<li>关系数据库可以将不同维度的信息隔离到不同的表，并用“键”关联，使数据的存储结构设计符合现实特性、更具人性面。</li>
<li>虚表是为查数据高效而生的，多个表用“键”关联后，可在数据库中生成虚拟的数据表，可以用于更多条件的组装和查找。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/33463930/">《操作系统导论》</a></li>
<li>极客时间《mysql实战45讲》</li>
</ul>
<p><strong>敬请期待下篇 图形识别</strong></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">杨润炜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://yangrunwei.com/a/125.html">https://yangrunwei.com/a/125.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/read/">read</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/a/126.html"><i class="fa fa-chevron-left">  </i><span>聊聊Go GMP调度模型</span></a></div><div class="next-post pull-right"><a href="/a/124.html"><span>简单总结《改变未来的九大算法》（三）——纠错码</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://yangrunwei.com/a/125.html';
  this.page.identifier = 'a/125.html';
  this.page.title = '简单总结《改变未来的九大算法》（四）——数据库如何实例一致性';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'cwalker-top' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://cwalker-top.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By 杨润炜</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>