<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="golang语言实践"><meta name="keywords" content="golang"><meta name="author" content="杨润炜"><meta name="copyright" content="杨润炜"><title>golang语言实践 | Cwalker</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">goroutine生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">反例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8chan%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">使用chan管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8context%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">使用context管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8errgroup%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">使用errgroup管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#errors-New%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.1.</span> <span class="toc-text">errors.New返回指针的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8errors-Wrapf%E8%B7%9F%E8%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.</span> <span class="toc-text">用errors.Wrapf跟踪异常的堆栈信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AEerrors"><span class="toc-number">2.2.1.</span> <span class="toc-text">使用系统内置errors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Eerrors-Wrapf%E6%8B%BF%E5%88%B0%E9%94%99%E8%AF%AF%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.2.</span> <span class="toc-text">从errors.Wrapf拿到错误堆栈信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#context%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">context的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E5%8F%96%E6%B6%88goroutine"><span class="toc-number">3.1.</span> <span class="toc-text">级联取消goroutine;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E3%80%81%E4%BC%A0%E9%80%92"><span class="toc-number">3.2.</span> <span class="toc-text">数据共享、传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">5.</span> <span class="toc-text">内存同步的方法与性能比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">6.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">杨润炜</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">135</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cwalker</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">golang语言实践</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/tech/"> tech</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o" aria-hidden="true"></i><a href="/a/116.html#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="a/116.html"></span></a></div><div class="article-container" id="post-content"><h2 id="goroutine生命周期管理"><a href="#goroutine生命周期管理" class="headerlink" title="goroutine生命周期管理"></a>goroutine生命周期管理</h2><p>使用goroutine需要注意的点：</p>
<ol>
<li>启动goroutine后，需要有机制能控制其如何退出，避免goroutine泄漏造成系统不稳定的风险；</li>
<li>尽量让调用者来决定是否使用goroutine；</li>
</ol>
<p>注：强烈推荐看看文末引用里关于goroutine leak的文章</p>
<h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><p>下面无法控制goroutine的例子，只能靠log.Fatal调用底层的os.exit退出，但这会使整个进程退出，有些正在处理的状态会因此中断，产生不可预料的异常；<br>在startServer内使用goroutine，调用者main函数并不知道其使用了goroutine，实际场景下可能会遗漏管理其非阻塞的特征。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// some goroutine...</span><br><span class="line">	startApp()</span><br><span class="line">	startDebug()</span><br><span class="line">	select &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startApp() &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startDebug() &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		if err := http.ListenAndServe(&quot;:8081&quot;, nil); err != nil &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用chan管理"><a href="#使用chan管理" class="headerlink" title="使用chan管理"></a>使用chan管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func startServer(addr string, stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line"></span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">		fmt.Fprintf(w, &quot;GET / OK&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr:    addr,</span><br><span class="line">		Handler: mux,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		&lt;-stop</span><br><span class="line">		log.Printf(&quot;addr: %s shuntDown&quot;, addr)</span><br><span class="line">		s.Shutdown(context.Background())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	return s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	stop := make(chan struct&#123;&#125;)</span><br><span class="line">	done := make(chan error, 2)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		done &lt;- startServer(&quot;:8080&quot;, stop) // app</span><br><span class="line">	&#125;()</span><br><span class="line">	go func() &#123;</span><br><span class="line">		done &lt;- startServer(&quot;:8081&quot;, stop) // debug</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">		if err := &lt;-done; err != nil &#123;</span><br><span class="line">			close(stop)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用context管理"><a href="#使用context管理" class="headerlink" title="使用context管理"></a>使用context管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func startServer(ctx context.Context, addr string) error &#123;</span><br><span class="line"></span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr: addr,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func(ctx context.Context) &#123;</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">		log.Printf(&quot;addr: %s shuntDown&quot;, addr)</span><br><span class="line">		s.Shutdown(ctx)</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	log.Printf(&quot;addr: %s start&quot;, addr)</span><br><span class="line">	return s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	go func() &#123;</span><br><span class="line">		startServer(ctx, &quot;:8080&quot;) // app</span><br><span class="line">	&#125;()</span><br><span class="line">	go func() &#123;</span><br><span class="line">		startServer(ctx, &quot;:8081&quot;) // debug</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	cancel()</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-time.After(2 * time.Second):</span><br><span class="line">		log.Print(&quot;done&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用errgroup管理"><a href="#使用errgroup管理" class="headerlink" title="使用errgroup管理"></a>使用errgroup管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	g, ctx := errgroup.WithContext(context.Background())</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		return startServer(ctx, &quot;3000&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		return startServer(ctx, &quot;4000&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		time.Sleep(2 * time.Second)</span><br><span class="line">		return errors.New(&quot;it&#x27;s time to exit&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	err := g.Wait()</span><br><span class="line">	log.Printf(&quot;exit, err: %v\n&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startServer(ctx context.Context, port string) error &#123;</span><br><span class="line">	log.Printf(&quot;startServer: %s\n&quot;, port)</span><br><span class="line">	srv := http.Server&#123;Addr: &quot;:&quot; + port&#125;</span><br><span class="line">	go func(ctx context.Context) &#123;</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">		if err := srv.Shutdown(ctx); err != nil &#123;</span><br><span class="line">			log.Printf(&quot;HTTP server %s Shutdown error: %v&quot;, srv.Addr, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(&quot;HTTP server %s Shutdown successfully&quot;, srv.Addr)</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	return srv.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol>
<li>error是一个值，而不是异常；</li>
<li>panic意味着程序挂了，谨慎使用；</li>
<li>errors.New返回指针类型，详情看<a target="_blank" rel="noopener" href="https://golang.org/src/errors/errors.go">error源码</a>；</li>
<li>使用errors.Wrapf跟踪错误堆栈；</li>
</ol>
<h3 id="errors-New返回指针的原因"><a href="#errors-New返回指针的原因" class="headerlink" title="errors.New返回指针的原因"></a>errors.New返回指针的原因</h3><p>errors.New返回的是指针，能够避免error字符串相同导致错误被误以为一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type myErrorString struct &#123;</span><br><span class="line">	s string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e myErrorString) Error() string &#123;</span><br><span class="line">	return e.s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// New create my error</span><br><span class="line">func New(s string) error &#123;</span><br><span class="line">	return myErrorString&#123;s&#125; // 这里返回的是字符串，而errors.New返回的是指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	var err1 = errors.New(&quot;test_err&quot;)</span><br><span class="line">	var err2 = errors.New(&quot;test_err&quot;)</span><br><span class="line"></span><br><span class="line">	if err1 == err2 &#123;</span><br><span class="line">		log.Println(&quot;err1 == err2&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var err3 = New(&quot;test_err&quot;)</span><br><span class="line">	var err4 = New(&quot;test_err&quot;)</span><br><span class="line">	if err3 == err4 &#123;</span><br><span class="line">		log.Println(&quot;err3 == err4&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用errors-Wrapf跟踪异常的堆栈信息"><a href="#用errors-Wrapf跟踪异常的堆栈信息" class="headerlink" title="用errors.Wrapf跟踪异常的堆栈信息"></a>用errors.Wrapf跟踪异常的堆栈信息</h3><h4 id="使用系统内置errors"><a href="#使用系统内置errors" class="headerlink" title="使用系统内置errors"></a>使用系统内置errors</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line"></span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ErrNotFound some data is not found</span><br><span class="line">var ErrNotFound = errors.New(&quot;not found&quot;)</span><br><span class="line"></span><br><span class="line">func dao(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	return nil, errors.New(&quot;not found&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func service(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	data, err := dao(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return data, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func api() &#123;</span><br><span class="line">	id := &quot;test&quot;</span><br><span class="line">	data, err := service(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		// only print: &quot;err: not found&quot;</span><br><span class="line">		log.Printf(&quot;err: %+v\n&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(&quot;found data: %+v\n&quot;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	api()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从errors-Wrapf拿到错误堆栈信息"><a href="#从errors-Wrapf拿到错误堆栈信息" class="headerlink" title="从errors.Wrapf拿到错误堆栈信息"></a>从errors.Wrapf拿到错误堆栈信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/pkg/errors&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ErrNotFound some data is not found</span><br><span class="line">var ErrNotFound = errors.New(&quot;not found&quot;)</span><br><span class="line"></span><br><span class="line">func dao(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	return nil, errors.Wrapf(ErrNotFound, &quot;id: %s is not found&quot;, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func service(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	data, err := dao(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return data, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func api() &#123;</span><br><span class="line">	id := &quot;test&quot;</span><br><span class="line">	data, err := service(id)</span><br><span class="line">	if errors.Cause(err) == ErrNotFound &#123;</span><br><span class="line">		// 打印出错误的堆栈</span><br><span class="line">		log.Printf(&quot;stack trace: \n%+v\n&quot;, err)</span><br><span class="line"></span><br><span class="line">		// 只打印根错误</span><br><span class="line">		log.Printf(&quot;original err: %+v\n&quot;, errors.Cause(err))</span><br><span class="line"></span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(&quot;found data: %+v\n&quot;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	api()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context的应用"><a href="#context的应用" class="headerlink" title="context的应用"></a>context的应用</h2><ol>
<li>级联取消goroutine；</li>
<li>数据共享、传递；</li>
</ol>
<h3 id="级联取消goroutine"><a href="#级联取消goroutine" class="headerlink" title="级联取消goroutine;"></a>级联取消goroutine;</h3><p><img src="/assets/uploads/files/1615129527838-4ec10931-66fc-4534-b4c1-06c93dc573ab-image-resized.png" alt="0_1615129527189_4ec10931-66fc-4534-b4c1-06c93dc573ab-image.png"><br>见上文中goroutine生命周期管理的【使用context管理】的代码。</p>
<h3 id="数据共享、传递"><a href="#数据共享、传递" class="headerlink" title="数据共享、传递"></a>数据共享、传递</h3><p>context可以存储kv数据，且数据可以通过context.WithValue传递给子函数，如果子函数从当前context的kv找不到，会自动递归父级的context查找，直到找到或父级为nil。<br><img src="/assets/uploads/files/1615128229433-8a198b9a-cd0f-4cbb-b8fa-ae2fea26193f-image-resized.png" alt="0_1615128228780_8a198b9a-cd0f-4cbb-b8fa-ae2fea26193f-image.png"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type favContextKey string</span><br><span class="line"></span><br><span class="line">var parentkey = favContextKey(&quot;parentKey&quot;)</span><br><span class="line">var childKey = favContextKey(&quot;childKey&quot;)</span><br><span class="line"></span><br><span class="line">func parent() &#123;</span><br><span class="line">	ctx := context.WithValue(context.Background(), parentkey, &quot;parentVal&quot;)</span><br><span class="line">	fmt.Printf(&quot;parentFn: parentVal: %+v\n&quot;, ctx.Value(parentkey))</span><br><span class="line">	child(context.WithValue(ctx, childKey, &quot;childVal&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func child(ctx context.Context) &#123;</span><br><span class="line">	fmt.Printf(&quot;childFn: parentVal: %+v\n&quot;, ctx.Value(parentkey))</span><br><span class="line">	fmt.Printf(&quot;childFn: childVal: %+v\n&quot;, ctx.Value(childKey))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	parent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>一般是用依赖注入的方式，方便单元测试；但依赖也因此要显式地在代码里不断传递，一般是自行进行依赖管理，如果依赖多了就需要不少这样的代码，wire能够减少依赖管理的代理，使其更加简洁。<br>详情看官方文档示例，比较清晰：<a target="_blank" rel="noopener" href="https://github.com/google/wire/blob/main/_tutorial/README.md">https://github.com/google/wire/blob/main/_tutorial/README.md</a></p>
<h2 id="内存同步的方法与性能比较"><a href="#内存同步的方法与性能比较" class="headerlink" title="内存同步的方法与性能比较"></a>内存同步的方法与性能比较</h2><ol>
<li><p>方法：锁（互斥锁、读写锁、原子操作）, chan实现无（显示）阻塞的内存同步；</p>
</li>
<li><p>由于atomic使用的是copy-on-write的方法在多任务间共享内存，所以不适用于大量数据的共享；</p>
</li>
<li><p>性能：原子操作&gt; 读写锁 &gt;？互斥锁 &gt;? chan；<br>原子操作：使用的是操作系统提供的CAS，不需要进行进程、线程或goroutine的切换；<br>读写锁、互斥锁：需要暂停其它goroutine，只保留相关的goroutine，涉及到goroutine的唤醒、暂停及其上下文切换的消耗；<br>chan：使用互斥锁实现，但其核心思想在于避免显示加锁，用通信的方式解决内存共享的多goroutine编程问题，因为锁编程的复杂度可能带来死锁、活锁、资源耗尽等风险；</p>
</li>
</ol>
<p>go写并发的核心思想:</p>
<blockquote>
</blockquote>
<p>Share memory by communicating, don’t communicate by sharing memory.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">package concurrency</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;sync/atomic&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Config struct &#123;</span><br><span class="line">	a []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var readerCount = 1</span><br><span class="line"></span><br><span class="line">func BenchmarkMutexMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var lock sync.RWMutex</span><br><span class="line">	cfg := Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				lock.RLock()</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(cfg.a[0]))</span><br><span class="line">				lock.RUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkAtomicMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var v atomic.Value</span><br><span class="line">	cfg := Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	v.Store(cfg)</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				d := v.Load().(Config)</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(d.a[0]))</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkMutexOneWriterMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var lock sync.RWMutex</span><br><span class="line">	var cfg = Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		var i = 0</span><br><span class="line">		for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">			i++</span><br><span class="line">			lock.Lock()</span><br><span class="line">			cfg = Config&#123;</span><br><span class="line">				a: []int&#123;i, i + 1, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">			&#125;</span><br><span class="line">			lock.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				lock.RLock()</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(cfg.a[0]))</span><br><span class="line">				lock.RUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkAtomicOneWriterMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var v atomic.Value</span><br><span class="line">	var cfg = Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	v.Store(cfg)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		var i = 0</span><br><span class="line">		for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">			i++</span><br><span class="line">			cfg = Config&#123;</span><br><span class="line">				a: []int&#123;i, i + 1, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">			&#125;</span><br><span class="line">			v.Store(cfg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				d := v.Load().(Config)</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(d.a[0]))</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkChanOneWriterMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	rc := make(chan int, 1000)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var cfg = Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		var i = 0</span><br><span class="line">		for msg := range rc &#123;</span><br><span class="line">			i++</span><br><span class="line">			switch msg &#123;</span><br><span class="line">			case 0:</span><br><span class="line">				cfg = Config&#123;</span><br><span class="line">					a: []int&#123;i, i + 1, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">			case 1:</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(cfg.a[0]))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">			rc &lt;- 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				rc &lt;- 1</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readerCounts为4的结果：<br><img src="https://img.yangrunwei.com/article-img/20210314/0a2b835d-ab27-4259-8180-6372aceaa978--1615299738739-3c0a9e90-bd03-4cb3-847e-352ddee2133c-image-resized.png"></p>
<p>readerCounts为1的结果：<br><img src="https://img.yangrunwei.com/article-img/20210314/23faf5c8-3537-4ccf-9426-d1502b03e55e--1615368652875-11ba810d-a4ea-448d-96c9-a4ce67bd24b0-image-resized.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">goroutine-leak</a><br><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549">atomic vs mutex</a><br><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c">go-trace</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">杨润炜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://yangrunwei.com/a/116.html">https://yangrunwei.com/a/116.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/a/117.html"><i class="fa fa-chevron-left">  </i><span>《如何阅读一本书》的感想与启发</span></a></div><div class="next-post pull-right"><a href="/a/115.html"><span>迟到的2020总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://yangrunwei.com/a/116.html';
  this.page.identifier = 'a/116.html';
  this.page.title = 'golang语言实践';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'cwalker-top' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://cwalker-top.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By 杨润炜</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>