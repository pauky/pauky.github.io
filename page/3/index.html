<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="杨润炜"><meta name="copyright" content="杨润炜"><title>Cwalker</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">杨润炜</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">137</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cwalker</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Cwalker</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/a/117.html">《如何阅读一本书》的感想与启发</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/life/">life</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/read/">read</a></span><div class="content"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我在生活中不缺少阅读的场景，比如看小说、读科普、看新闻甚至刷朋友圈、脸书、推特。然后当我阅读完这本书，才意识到之前所谓的阅读只不过是“走马观花”，而且“花”往往是资讯、消遣类的东西，除了在上学时“观”的是知识、经验，然大都是被动的获取——死记硬背而已。所以这本书<code>主要</code>在说的就是与这类相反的技巧、经验——要<code>主动地阅读</code>，什么是主动阅读，怎样主动阅读，以及为何要主动阅读。</p>
<h2 id="本书的总结"><a href="#本书的总结" class="headerlink" title="本书的总结"></a>本书的总结</h2><p>以下我将先用本书介绍的阅读技巧——分析阅读——来总结本书，也作为一个技巧练习的示例吧。</p>
<h4 id="本书的内容"><a href="#本书的内容" class="headerlink" title="本书的内容"></a>本书的内容</h4><p>这是一本实用类的书，作者讲述了阅读的技巧——主动阅读、提问、探寻结论，以及主动阅读能够增强心智、理解力的好处。</p>
<h4 id="作者如何论述的"><a href="#作者如何论述的" class="headerlink" title="作者如何论述的"></a>作者如何论述的</h4><p>总在来说是通过阅读的四个阶段来论述：</p>
<ul>
<li>基础阅读：识字，理解文字表面意思；</li>
<li>检视阅读：快速查阅，得出文字主旨；</li>
<li>分析阅读：理解作者在文中的假设、结论、想要解决以及未解决的问题，以及论述的逻辑，在阅读中不断提问、探寻答案，真正理解了作者在文本的主旨；</li>
<li>主题阅读：阅读的最终目标，结合不同作者的主旨，主动地探寻自己想要解决的问题。<br>四个阶段是层层递进，后者包含前者的。每一层的推进，都需要先提升自己的理解力到达一定的层次，当然还需要一些阅读技巧。<br>以上这些可以用在论述类的书，而对于非论述的书，作者也列举了常见非论述类型书的阅读技巧和经验。</li>
<li>历史书：除了了解非“真实”的故事，更需要从中得出适用于现实的经验；</li>
<li>科学、数学书：了解科学的历史和基本原理，知道其中的假设、分析、结论，不需要达到专家的理解水平；</li>
<li>哲学：由于抽象来源于自己的经验，所以需要了解作者及当时的社会背景，才有可能get到作者真正想说的，再加上自己的思考才能摸到作者的答案；</li>
<li>想象类文学（戏剧、诗）：不要去找共识和主旨或论述，它们是不具有逻辑的，唯一要做的是去感受与体验；</li>
<li>社会科学：一般与日常经验相符较容易入门阅读，但因涉及的领域广，边界模糊，所以往往很难真正下结论，特别是只从一本书中得出结论，所以要用主题阅读。<br>最后，作者也点明了阅读与心智成长的关系。</li>
</ul>
<h4 id="这本书是否真实？（它说得有道理吗？部分还是全部？）"><a href="#这本书是否真实？（它说得有道理吗？部分还是全部？）" class="headerlink" title="这本书是否真实？（它说得有道理吗？部分还是全部？）"></a>这本书是否真实？（它说得有道理吗？部分还是全部？）</h4><p>我觉得是十分符合经验的，且是能够启发出新的经验。</p>
<h4 id="这本书跟我有什么关系？"><a href="#这本书跟我有什么关系？" class="headerlink" title="这本书跟我有什么关系？"></a>这本书跟我有什么关系？</h4><p>让一个只会基础阅读的新手，感受到阅读的真正目标以及魅力。</p>
<p>以上就是我对本书的总结，取自对于印象和启发较多的部分，强烈推荐阅读本书获取更多的细节，因为其对于阅读新手来说信息量确实比较大。</p>
<h2 id="本书对我的启发"><a href="#本书对我的启发" class="headerlink" title="本书对我的启发"></a>本书对我的启发</h2><p>下面将来说下其对我的一些关于教育、学习的启发。</p>
<h3 id="教育方面"><a href="#教育方面" class="headerlink" title="教育方面"></a>教育方面</h3><p>读书那会常听到两个声音，读书有用或无用论，两派各持一词谁也说服不了谁。因为都能举出读书出人头地和诸如“上清华卖猪肉的例子”。先不探究事实是否如此，就拿自己读书、工作这段时间的感受来说，读书的利弊确实都有，利在于常规知识、经验的高效积累，这是普遍人自学难以匹敌的，而弊就是缺乏社会经历、人情世故、甚至是主动思考的意识。<br>然后读了本书我才意识到，其实教育的坏处应该不是教育本身产生的，而是作为当事人 我的问题。暂且不说社会经历，这块确实无法直接补充。但教育让人读书，为的是先让人识字、快速掌握常识，才有机会能够主动从书（或其它老师等知识传播的媒介）中增强自己对于社会、世界的理解力，增强心智的力量。</p>
<h3 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h3><p>学习不只是掌握新的技能，更要掌握能够发现问题、分析问题、尝试探寻答案的力量和经验。这是从本书自始至终强调地主动阅读，主动就是在阅读中不断提问题、找答案、总结的过程。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这本书一开始读了第一遍之后马上又进入第二遍，把重点的内容重新审视和思考，因为作者对于阅读应该主动的看法吸引了我，而当时一遍下来已经忘记了前面的很多问题本身以及论述。目前我的理解水平也只能得出这些体会和技巧，且觉得如果理解力再高一些肯定能体会得更多，所以这是一本值得后续多刷的好书。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/116.html">golang语言实践</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/golang/">golang</a></span><div class="content"><h2 id="goroutine生命周期管理"><a href="#goroutine生命周期管理" class="headerlink" title="goroutine生命周期管理"></a>goroutine生命周期管理</h2><p>使用goroutine需要注意的点：</p>
<ol>
<li>启动goroutine后，需要有机制能控制其如何退出，避免goroutine泄漏造成系统不稳定的风险；</li>
<li>尽量让调用者来决定是否使用goroutine；</li>
</ol>
<p>注：强烈推荐看看文末引用里关于goroutine leak的文章</p>
<h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><p>下面无法控制goroutine的例子，只能靠log.Fatal调用底层的os.exit退出，但这会使整个进程退出，有些正在处理的状态会因此中断，产生不可预料的异常；<br>在startServer内使用goroutine，调用者main函数并不知道其使用了goroutine，实际场景下可能会遗漏管理其非阻塞的特征。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// some goroutine...</span><br><span class="line">	startApp()</span><br><span class="line">	startDebug()</span><br><span class="line">	select &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startApp() &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startDebug() &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		if err := http.ListenAndServe(&quot;:8081&quot;, nil); err != nil &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用chan管理"><a href="#使用chan管理" class="headerlink" title="使用chan管理"></a>使用chan管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func startServer(addr string, stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line"></span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">		fmt.Fprintf(w, &quot;GET / OK&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr:    addr,</span><br><span class="line">		Handler: mux,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		&lt;-stop</span><br><span class="line">		log.Printf(&quot;addr: %s shuntDown&quot;, addr)</span><br><span class="line">		s.Shutdown(context.Background())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	return s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	stop := make(chan struct&#123;&#125;)</span><br><span class="line">	done := make(chan error, 2)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		done &lt;- startServer(&quot;:8080&quot;, stop) // app</span><br><span class="line">	&#125;()</span><br><span class="line">	go func() &#123;</span><br><span class="line">		done &lt;- startServer(&quot;:8081&quot;, stop) // debug</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">		if err := &lt;-done; err != nil &#123;</span><br><span class="line">			close(stop)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用context管理"><a href="#使用context管理" class="headerlink" title="使用context管理"></a>使用context管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func startServer(ctx context.Context, addr string) error &#123;</span><br><span class="line"></span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr: addr,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func(ctx context.Context) &#123;</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">		log.Printf(&quot;addr: %s shuntDown&quot;, addr)</span><br><span class="line">		s.Shutdown(ctx)</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	log.Printf(&quot;addr: %s start&quot;, addr)</span><br><span class="line">	return s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	go func() &#123;</span><br><span class="line">		startServer(ctx, &quot;:8080&quot;) // app</span><br><span class="line">	&#125;()</span><br><span class="line">	go func() &#123;</span><br><span class="line">		startServer(ctx, &quot;:8081&quot;) // debug</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	cancel()</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-time.After(2 * time.Second):</span><br><span class="line">		log.Print(&quot;done&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用errgroup管理"><a href="#使用errgroup管理" class="headerlink" title="使用errgroup管理"></a>使用errgroup管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	g, ctx := errgroup.WithContext(context.Background())</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		return startServer(ctx, &quot;3000&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		return startServer(ctx, &quot;4000&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		time.Sleep(2 * time.Second)</span><br><span class="line">		return errors.New(&quot;it&#x27;s time to exit&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	err := g.Wait()</span><br><span class="line">	log.Printf(&quot;exit, err: %v\n&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startServer(ctx context.Context, port string) error &#123;</span><br><span class="line">	log.Printf(&quot;startServer: %s\n&quot;, port)</span><br><span class="line">	srv := http.Server&#123;Addr: &quot;:&quot; + port&#125;</span><br><span class="line">	go func(ctx context.Context) &#123;</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">		if err := srv.Shutdown(ctx); err != nil &#123;</span><br><span class="line">			log.Printf(&quot;HTTP server %s Shutdown error: %v&quot;, srv.Addr, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(&quot;HTTP server %s Shutdown successfully&quot;, srv.Addr)</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	return srv.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol>
<li>error是一个值，而不是异常；</li>
<li>panic意味着程序挂了，谨慎使用；</li>
<li>errors.New返回指针类型，详情看<a target="_blank" rel="noopener" href="https://golang.org/src/errors/errors.go">error源码</a>；</li>
<li>使用errors.Wrapf跟踪错误堆栈；</li>
</ol>
<h3 id="errors-New返回指针的原因"><a href="#errors-New返回指针的原因" class="headerlink" title="errors.New返回指针的原因"></a>errors.New返回指针的原因</h3><p>errors.New返回的是指针，能够避免error字符串相同导致错误被误以为一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type myErrorString struct &#123;</span><br><span class="line">	s string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e myErrorString) Error() string &#123;</span><br><span class="line">	return e.s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// New create my error</span><br><span class="line">func New(s string) error &#123;</span><br><span class="line">	return myErrorString&#123;s&#125; // 这里返回的是字符串，而errors.New返回的是指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	var err1 = errors.New(&quot;test_err&quot;)</span><br><span class="line">	var err2 = errors.New(&quot;test_err&quot;)</span><br><span class="line"></span><br><span class="line">	if err1 == err2 &#123;</span><br><span class="line">		log.Println(&quot;err1 == err2&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var err3 = New(&quot;test_err&quot;)</span><br><span class="line">	var err4 = New(&quot;test_err&quot;)</span><br><span class="line">	if err3 == err4 &#123;</span><br><span class="line">		log.Println(&quot;err3 == err4&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用errors-Wrapf跟踪异常的堆栈信息"><a href="#用errors-Wrapf跟踪异常的堆栈信息" class="headerlink" title="用errors.Wrapf跟踪异常的堆栈信息"></a>用errors.Wrapf跟踪异常的堆栈信息</h3><h4 id="使用系统内置errors"><a href="#使用系统内置errors" class="headerlink" title="使用系统内置errors"></a>使用系统内置errors</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line"></span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ErrNotFound some data is not found</span><br><span class="line">var ErrNotFound = errors.New(&quot;not found&quot;)</span><br><span class="line"></span><br><span class="line">func dao(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	return nil, errors.New(&quot;not found&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func service(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	data, err := dao(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return data, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func api() &#123;</span><br><span class="line">	id := &quot;test&quot;</span><br><span class="line">	data, err := service(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		// only print: &quot;err: not found&quot;</span><br><span class="line">		log.Printf(&quot;err: %+v\n&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(&quot;found data: %+v\n&quot;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	api()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从errors-Wrapf拿到错误堆栈信息"><a href="#从errors-Wrapf拿到错误堆栈信息" class="headerlink" title="从errors.Wrapf拿到错误堆栈信息"></a>从errors.Wrapf拿到错误堆栈信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/pkg/errors&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ErrNotFound some data is not found</span><br><span class="line">var ErrNotFound = errors.New(&quot;not found&quot;)</span><br><span class="line"></span><br><span class="line">func dao(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	return nil, errors.Wrapf(ErrNotFound, &quot;id: %s is not found&quot;, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func service(id string) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	data, err := dao(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return data, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func api() &#123;</span><br><span class="line">	id := &quot;test&quot;</span><br><span class="line">	data, err := service(id)</span><br><span class="line">	if errors.Cause(err) == ErrNotFound &#123;</span><br><span class="line">		// 打印出错误的堆栈</span><br><span class="line">		log.Printf(&quot;stack trace: \n%+v\n&quot;, err)</span><br><span class="line"></span><br><span class="line">		// 只打印根错误</span><br><span class="line">		log.Printf(&quot;original err: %+v\n&quot;, errors.Cause(err))</span><br><span class="line"></span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(&quot;found data: %+v\n&quot;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	api()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context的应用"><a href="#context的应用" class="headerlink" title="context的应用"></a>context的应用</h2><ol>
<li>级联取消goroutine；</li>
<li>数据共享、传递；</li>
</ol>
<h3 id="级联取消goroutine"><a href="#级联取消goroutine" class="headerlink" title="级联取消goroutine;"></a>级联取消goroutine;</h3><p><img src="/assets/uploads/files/1615129527838-4ec10931-66fc-4534-b4c1-06c93dc573ab-image-resized.png" alt="0_1615129527189_4ec10931-66fc-4534-b4c1-06c93dc573ab-image.png"><br>见上文中goroutine生命周期管理的【使用context管理】的代码。</p>
<h3 id="数据共享、传递"><a href="#数据共享、传递" class="headerlink" title="数据共享、传递"></a>数据共享、传递</h3><p>context可以存储kv数据，且数据可以通过context.WithValue传递给子函数，如果子函数从当前context的kv找不到，会自动递归父级的context查找，直到找到或父级为nil。<br><img src="/assets/uploads/files/1615128229433-8a198b9a-cd0f-4cbb-b8fa-ae2fea26193f-image-resized.png" alt="0_1615128228780_8a198b9a-cd0f-4cbb-b8fa-ae2fea26193f-image.png"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type favContextKey string</span><br><span class="line"></span><br><span class="line">var parentkey = favContextKey(&quot;parentKey&quot;)</span><br><span class="line">var childKey = favContextKey(&quot;childKey&quot;)</span><br><span class="line"></span><br><span class="line">func parent() &#123;</span><br><span class="line">	ctx := context.WithValue(context.Background(), parentkey, &quot;parentVal&quot;)</span><br><span class="line">	fmt.Printf(&quot;parentFn: parentVal: %+v\n&quot;, ctx.Value(parentkey))</span><br><span class="line">	child(context.WithValue(ctx, childKey, &quot;childVal&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func child(ctx context.Context) &#123;</span><br><span class="line">	fmt.Printf(&quot;childFn: parentVal: %+v\n&quot;, ctx.Value(parentkey))</span><br><span class="line">	fmt.Printf(&quot;childFn: childVal: %+v\n&quot;, ctx.Value(childKey))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	parent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>一般是用依赖注入的方式，方便单元测试；但依赖也因此要显式地在代码里不断传递，一般是自行进行依赖管理，如果依赖多了就需要不少这样的代码，wire能够减少依赖管理的代理，使其更加简洁。<br>详情看官方文档示例，比较清晰：<a target="_blank" rel="noopener" href="https://github.com/google/wire/blob/main/_tutorial/README.md">https://github.com/google/wire/blob/main/_tutorial/README.md</a></p>
<h2 id="内存同步的方法与性能比较"><a href="#内存同步的方法与性能比较" class="headerlink" title="内存同步的方法与性能比较"></a>内存同步的方法与性能比较</h2><ol>
<li><p>方法：锁（互斥锁、读写锁、原子操作）, chan实现无（显示）阻塞的内存同步；</p>
</li>
<li><p>由于atomic使用的是copy-on-write的方法在多任务间共享内存，所以不适用于大量数据的共享；</p>
</li>
<li><p>性能：原子操作&gt; 读写锁 &gt;？互斥锁 &gt;? chan；<br>原子操作：使用的是操作系统提供的CAS，不需要进行进程、线程或goroutine的切换；<br>读写锁、互斥锁：需要暂停其它goroutine，只保留相关的goroutine，涉及到goroutine的唤醒、暂停及其上下文切换的消耗；<br>chan：使用互斥锁实现，但其核心思想在于避免显示加锁，用通信的方式解决内存共享的多goroutine编程问题，因为锁编程的复杂度可能带来死锁、活锁、资源耗尽等风险；</p>
</li>
</ol>
<p>go写并发的核心思想:</p>
<blockquote>
</blockquote>
<p>Share memory by communicating, don’t communicate by sharing memory.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">package concurrency</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;sync/atomic&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Config struct &#123;</span><br><span class="line">	a []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var readerCount = 1</span><br><span class="line"></span><br><span class="line">func BenchmarkMutexMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var lock sync.RWMutex</span><br><span class="line">	cfg := Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				lock.RLock()</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(cfg.a[0]))</span><br><span class="line">				lock.RUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkAtomicMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var v atomic.Value</span><br><span class="line">	cfg := Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	v.Store(cfg)</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				d := v.Load().(Config)</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(d.a[0]))</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkMutexOneWriterMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var lock sync.RWMutex</span><br><span class="line">	var cfg = Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		var i = 0</span><br><span class="line">		for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">			i++</span><br><span class="line">			lock.Lock()</span><br><span class="line">			cfg = Config&#123;</span><br><span class="line">				a: []int&#123;i, i + 1, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">			&#125;</span><br><span class="line">			lock.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				lock.RLock()</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(cfg.a[0]))</span><br><span class="line">				lock.RUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkAtomicOneWriterMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var v atomic.Value</span><br><span class="line">	var cfg = Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	v.Store(cfg)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		var i = 0</span><br><span class="line">		for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">			i++</span><br><span class="line">			cfg = Config&#123;</span><br><span class="line">				a: []int&#123;i, i + 1, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">			&#125;</span><br><span class="line">			v.Store(cfg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				d := v.Load().(Config)</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(d.a[0]))</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkChanOneWriterMultipleReaders(b *testing.B) &#123;</span><br><span class="line">	rc := make(chan int, 1000)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	var lastValue uint64</span><br><span class="line">	var cfg = Config&#123;</span><br><span class="line">		a: []int&#123;0, 0, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		var i = 0</span><br><span class="line">		for msg := range rc &#123;</span><br><span class="line">			i++</span><br><span class="line">			switch msg &#123;</span><br><span class="line">			case 0:</span><br><span class="line">				cfg = Config&#123;</span><br><span class="line">					a: []int&#123;i, i + 1, 0, 0, 0, 0, 0&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">			case 1:</span><br><span class="line">				atomic.SwapUint64(&amp;lastValue, uint64(cfg.a[0]))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">			rc &lt;- 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for n := 0; n &lt; readerCount; n++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">				rc &lt;- 1</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readerCounts为4的结果：<br><img src="https://img.yangrunwei.com/article-img/20210314/0a2b835d-ab27-4259-8180-6372aceaa978--1615299738739-3c0a9e90-bd03-4cb3-847e-352ddee2133c-image-resized.png"></p>
<p>readerCounts为1的结果：<br><img src="https://img.yangrunwei.com/article-img/20210314/23faf5c8-3537-4ccf-9426-d1502b03e55e--1615368652875-11ba810d-a4ea-448d-96c9-a4ce67bd24b0-image-resized.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">goroutine-leak</a><br><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549">atomic vs mutex</a><br><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c">go-trace</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/115.html">迟到的2020总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/life/">life</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/year-end-summary/">year end summary</a></span><div class="content"><h2 id="为啥迟到了？"><a href="#为啥迟到了？" class="headerlink" title="为啥迟到了？"></a>为啥迟到了？</h2><p>因为太懒了。。。<br>除了身体上的懒，还是意识上的懒。还没有意识到总结对于成长的作用。<br>又要立flag了，每年都来一份年终大总结。回顾过去走过的，看看今后要怎样走。</p>
<h2 id="2020都遇到了啥？"><a href="#2020都遇到了啥？" class="headerlink" title="2020都遇到了啥？"></a>2020都遇到了啥？</h2><h3 id="从《深入浅出计算机组成原理》出发"><a href="#从《深入浅出计算机组成原理》出发" class="headerlink" title="从《深入浅出计算机组成原理》出发"></a>从《深入浅出计算机组成原理》出发</h3><p>这是当时的<a target="_blank" rel="noopener" href="https://www.yangrunwei.com/a/102.html">笔记</a>。<br>这门课还是在极客时间上的专栏，当时出于好奇去看的，看完后对底层的知识产生了很大的兴趣，想知识更多关于这个或那个的原理，从而才有了后面的学习之路。</p>
<h3 id="踩入无底的-数据结构与算法-深潭"><a href="#踩入无底的-数据结构与算法-深潭" class="headerlink" title="踩入无底的 数据结构与算法 深潭"></a>踩入无底的 数据结构与算法 深潭</h3><p>开年第一站就是数据结构与算法的训练。数据结构相对好理解，常见的那些数组、栈、树、图，平时可能会接触过。但算法就着实令人头大，光是递归就理解了大半天，更别提动态规划。当时是通过leetcode刷题和极客时间的算法训练营来学习，努力了这一番，熟悉了基本的原理（套路），也体现到了算法对于思维严谨性训练的好处。<br>后来在leetcode上刷题，从一开始搅尽脑汁，到现在逐渐有了一些肌肉记忆和较浅的套路及数学意识。路真的不好走，但没办法，编程最后就是数学、算法、工程，这些是绕不过去的。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/glowry/">这儿</a>能看到我在leetcode上的战绩，期待一同学习进步。</p>
<h3 id="在-架构设计-里感叹"><a href="#在-架构设计-里感叹" class="headerlink" title="在 架构设计 里感叹"></a>在 架构设计 里感叹</h3><p>上了极客时间的李智慧老师的课，看到了一个架构师那种宏大的视野，无论是技术、业务、沟通、思考、管理。</p>
<h3 id="交了个新朋友，叫golang"><a href="#交了个新朋友，叫golang" class="headerlink" title="交了个新朋友，叫golang"></a>交了个新朋友，叫golang</h3><p>进行golang的学习，一方面是想通过它来了解更多底层的东西，因为平时用node.js写，被封装得太上层了，另一方面就是工作原因，因为公司想推golang技术栈，我作为小组的组长，需要走在前面做好带头作用。目前在go训练营里也学到了不少东西，除了语言实践、goruntime原理，还有工程实践与设计，架构设计也涉及到了，受益良多。</p>
<h3 id="又交了几个好笔友，推荐给大家"><a href="#又交了几个好笔友，推荐给大家" class="headerlink" title="又交了几个好笔友，推荐给大家"></a>又交了几个好笔友，推荐给大家</h3><h4 id="《编码》"><a href="#《编码》" class="headerlink" title="《编码》"></a>《编码》</h4><p>这是当时的<a target="_blank" rel="noopener" href="https://www.yangrunwei.com/a/107.html">笔记</a>。<br>在大师的宏观的视角下，浏览了计算机的由来及发展，还有其背后的数学原理，文中还包含一些生动有趣的童年故事、各种奇思妙想但又巧妙地符合原理的小实例，让我实实在在地感受到了计算机实质般的存在，因为一直在软件这块，觉得硬件底层的东西很神秘。</p>
<h4 id="《汇编语言》"><a href="#《汇编语言》" class="headerlink" title="《汇编语言》"></a>《汇编语言》</h4><p>这本是耗时最大的书了，因为书上的实验基本都做了（笔记放<a target="_blank" rel="noopener" href="https://github.com/pauky/Assembly-Language">github</a>上了），虽然有些是参照了网上的资料，但也理解消化了。读这本书是因为要学《CSAPP》，其第二部分有关汇编的知识看不懂，所以在网上的推荐找了这本书。读完又做了练习，确实对底层的知识有了一层了解，对汇编如何实现栈、数组、结构体、变量赋值、输入输出、中断、寻址、函数调用等有了更感性和直接的体会。</p>
<h4 id="《深入理解计算机系统》别名《CSAPP》（第一、二部分）"><a href="#《深入理解计算机系统》别名《CSAPP》（第一、二部分）" class="headerlink" title="《深入理解计算机系统》别名《CSAPP》（第一、二部分）"></a>《深入理解计算机系统》别名《CSAPP》（第一、二部分）</h4><p>可以说所有今年的学习其实都围绕这本书在打基础，因为它几乎受所有的高手所推荐，是程序员必读的书。虽说人家是外国大学本科教材，但对目前的我来说还是比较深入的知识，我正在逐渐攻破。目前书看到第二部分，但因为书啃起来比较久，所以也在网易公开课上看视频，想先有个宏观上的认识，但看书看细节，做题，并实践更多的东西，后面也会多做这块的实践总结出来。<br>相关的笔记放在<a target="_blank" rel="noopener" href="https://github.com/pauky/csapp-3e-note">github</a>上了。</p>
<h4 id="《操作系统导论》"><a href="#《操作系统导论》" class="headerlink" title="《操作系统导论》"></a>《操作系统导论》</h4><p>这本书太好了，给了我对操作系统原理的一个比较宏观又在要领上十分清晰的脉络。本书将操作系统特点总结为并发、持久化、虚拟化。虚拟化指的是进程、线程对CPU资源，虚拟内存对内存，文件系统对磁盘等；并发讲述了锁、原子操作的设计、发展、实现；持久化主要是讲述各种文件系统的基本原理。</p>
<h4 id="《图解TCP-x2F-IP》"><a href="#《图解TCP-x2F-IP》" class="headerlink" title="《图解TCP&#x2F;IP》"></a>《图解TCP&#x2F;IP》</h4><p>在看这本之前，基本是看在《TCP&#x2F;IP详解》，但它真的太干了，目前小白的我还搞不定，只能“曲线救国”般地先找来入门的书看看。书中浅析了网络各层次的协议及应用，用简单直观的图片来讲述网络底层交互、数据结构及拓扑，虽说很多协议是“走马观花”，但确实扩宽了我对计算机网络的视野。</p>
<h4 id="《鸟哥的linux私有菜》基础学习篇"><a href="#《鸟哥的linux私有菜》基础学习篇" class="headerlink" title="《鸟哥的linux私有菜》基础学习篇"></a>《鸟哥的linux私有菜》基础学习篇</h4><p>主要是看看怎样运维linux系统，因为程序最终都在Linux跑，需要多了解些linux命令和运维知识，另外也想为后面了解linux原理打打基础。</p>
<h4 id="《程序员修炼之道（英文版）》"><a href="#《程序员修炼之道（英文版）》" class="headerlink" title="《程序员修炼之道（英文版）》"></a>《程序员修炼之道（英文版）》</h4><p>纯粹是想学学英文阅读，拿来晚上睡前读读，很多单词不懂，但借着对大意的把握，也能看懂部分。</p>
<h4 id="《你的灯亮着吗？》"><a href="#《你的灯亮着吗？》" class="headerlink" title="《你的灯亮着吗？》"></a>《你的灯亮着吗？》</h4><p>在团队里也时常需要与产品一同进行需求分析与设计，本书给了我一个很重要的意识：别太相信客户的描述，为其找到真正的需求，并合理地解决，对双方才是最好的。<br>以下是当时的<a target="_blank" rel="noopener" href="https://www.yangrunwei.com/a/114.html">笔记</a>;</p>
<h2 id="立下今年的flag，再接再励"><a href="#立下今年的flag，再接再励" class="headerlink" title="立下今年的flag，再接再励"></a>立下今年的flag，再接再励</h2><ol>
<li>要成功转入golang技术栈，实践至少3个项目；</li>
<li>阅读并实践《CSAPP》、《UNIX环境高级编程》、《UNIX网络编程》、《自己动手写操作系统》等书；</li>
<li>至少为1个出名的开源项目贡献代码（这个真的十分重要，也是我觉得很酷的事，写的东西能给很多很多人使用，且得到认可）；</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/114.html">《你的灯亮着吗？》 读后感 NO.1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/life/">life</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/read/">read</a></span><div class="content"><p>这本书是在架构师训练营里老师推荐的，对它的第一印象是讲关于发现问题、解决问题的。目前在工作中带了个小团队，团队的事情经常需要带头的人来决策，觉得这书应该能给我一些启示。<br>这本薄薄的、包含几则贴近日常工作和生活小故事的书，一个下午就轻松读完，但绝对值得品读。可能是作者从事的是计算机相关的咨询工作，所以列举的故事对于我这个程序员来说很贴切。接下来我将针对其中一些印象比较深的点谈一些感受，也是个梳理、总结的过程。</p>
<h3 id="电梯的故事"><a href="#电梯的故事" class="headerlink" title="电梯的故事"></a>电梯的故事</h3><p>故事讲述的是一栋商业大厦的租户因为不满电梯慢而抱怨、投诉房东，房东找人用巧妙的方法“解决”了这事，让大家忽略了不满的情绪。直到电梯维修者发现了电梯慢的原因，修好了电梯，但却出现了电梯太快导致出口人满为患的问题。<br>一般大家都明白遇到事情多问几个为什么的道理，一开始用出来可能就发现问题根源了。当问题降临到解决者身上，我们首先看到的是房东有麻烦，是因为租户不满，租房不满是因为上下楼等电梯排队时间久，排队久是因为电梯慢，那是不是一开始就可以先尝试找下为什么电梯慢？那估计这个问题也很快解决了。</p>
<h3 id="投标的故事"><a href="#投标的故事" class="headerlink" title="投标的故事"></a>投标的故事</h3><p>有个政治的投标，竞标者都报了价后，有几个公司作弊得到其它公司竞价的信息，且可以有一次改价的机会，但因为可能的结果很多，需要评估各种情况，获取最大的收益，所以找来技术外包解决。虽然当时用技术算出了所谓的最终结果，使当时的解决者都觉得自己找出了问题的解决方案并解决了问题。但都忽略了投标这个事，一开始评估收益就不是个技术的问题，而是个信息不对称，类似博弈的问题。因为数据从几个公司同时作弊后就不是原来的样子了。<br>到底问题是什么？有时候真的很难找到，上面的故事就是例子，如果问题是怎样得到最大收益，那问题将会变成怎样计算各种可能，但各种可能又会因为竞标者掌握的信息或是否作弊而变化，这就导致问题链无限延长。最终还不如按照规则竞标，还省去了作弊的成本。<br>另外，书中还介绍了，如果从不同角度看日常上习以为常的事物，往往也能发现各种问题。所以我想作者想释放的信息应该是问题是什么，关键在于用什么角度去看待问题，明确了站在问题者的角度上遇到的问题，你的解决方案都是有效的。</p>
<h3 id="关车灯的故事"><a href="#关车灯的故事" class="headerlink" title="关车灯的故事"></a>关车灯的故事</h3><p>这也是本书标题的来源。有个新隧道，末端连接着免费的公园，但因为隧道，去公园的车辆都会开着灯过来，然后停车忘记关灯，最后回去的时候车没电，抱怨起景区，景区又压到隧道工程上，最终问题来到了工程师手中，最后工程师在出隧道的地方竖立一块牌子，写着“你的车灯亮着吗？”，提醒司机关车灯，问题就此消散。<br>解决问题的方法多巧妙啊！恰到好处，关键是省钱省力。<br>然后这个故事是为了说明问题该由谁解决的事。按照分析，问题可能要由景区、警察、政府、工程师、司机其中一者来解决，这其中工程师可能是最弱势的，所以接到了这个问题。好在分析准确，找出了司机才是问题的解决者，与其通过各种方法去事后弥补车没电的事，还不如想想怎样提醒司机。那接下来的关键是怎样提醒，我觉得这就是个巧妙的方法了，只要坚定了第一步的方向，后面标语还可以再优化迭代。</p>
<h3 id="玩具厂的事情"><a href="#玩具厂的事情" class="headerlink" title="玩具厂的事情"></a>玩具厂的事情</h3><p>这是个让程序员感到无奈的事。对我的警示应该是最大的。故事是说厂领导想要程序员依据数据，算出三个分厂的生产、运输成本，利用计算机算出高效的方案。最后勤奋的程序员自认为找到了答案，汇报给厂领导，提议关闭其中两个厂后成本最低，然而没想到领导早已知道这个答案，但因为老板的家在需要关闭的厂旁边，不想到离家太远的地方上班。这就跟之前的需求矛盾了呀，一开始不就是要降低成本的嘛，搞到最后是降低成本跟讨好老板冲突了，在想发财就要降成本，降成本又会得罪老板，得罪老板又不能发财的矛盾上，这可能才是这次的问题吧。<br>这些在平时工作中真的很常见，产品提了客户需求，程序员拿着需求以为是问题就开始搞设计、开发，最后才知道这只是客户提的解决方案，而且是没办法解决客户问题的方案，在没明白前便是不断返工，直到把项目搞黄。<br>书中也指出了，往往提出问题的人，在你跟他说明问题之前，他并不知道面临的问题是什么。</p>
<h3 id="自己生活中的例子"><a href="#自己生活中的例子" class="headerlink" title="自己生活中的例子"></a>自己生活中的例子</h3><p>当时客户收到客户投诉，说我们的服务效果有问题。当时是反馈到我这，我想当然地以为客户想解决效果问题，没想到解释了一大堆，客户还是不满意。然后我们运营的妹子介入，首先以一句“抱歉影响到您”的软话，然后再几句简述后续的优化计划，客户便接受并退去了。<br>事后才知道，往往客户投诉并不是想要解决效果问题，而只是想要个道歉平息下内心的不满，可能是受到上层的压力，也可能是加班修复了问题带来的后果。</p>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>以上只是我的一点小小体会，作为程序员对书中某些场景也是感触良多。我觉得它适合在工作生活中不断地读，有些场景之所以印象不深，是还没有遇到或者没有思考过，当自己经历或思考过，再读的话，感触应该会更深，也能真正反馈到平时的待人处事当中。<br>以下是我第一次阅读后能够想出的一些总结性的话：</p>
<ul>
<li>不要把解决方案当问题；</li>
<li>问题的解决者要先找到问题是什么，然后明确谁要对问题负责（即谁要去解决问题）；</li>
<li>从不同角度看可以发现更多的问题，所以问题是什么是首先要清楚的；</li>
<li>提出问题的人往往不知道自己的问题什么了，在没有充分沟通前，不要轻易下结论，特别是从事计算机的，总觉得技术能解决一切问题，很多时候往往并不是一个技术问题。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/113.html">算法现学现卖——归并排序求逆序对的升级版</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="归并排序求逆序对的升级版"><a href="#归并排序求逆序对的升级版" class="headerlink" title="归并排序求逆序对的升级版"></a>归并排序求逆序对的升级版</h1><p>今天leetcode的每日一题 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a><br>先来试试暴力解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        counts = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur = nums[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> cur &gt; nums[j]:</span><br><span class="line">                    counts[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure>
<p>结果是超时，时间复杂度是O(n^2)。这肯定是需要高级解法了。先把高级解法抛出来：归并排序求逆序对，且利用“索引数组”。</p>
<ul>
<li><p>不知道啥是逆序对？<br>那先来了解下逆序对：某个数比后面的数大，这两个数就构成逆序对。</p>
</li>
<li><p>忘记啥是归并排序？<br>那先复习一道排序题吧</p>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a><br>关键还是递归的思想，将数组拆分为两份，每一份相当于独立的子问题，继续按前面的方法拆分，直到不可拆，再向上合并，合并的时候每一份数据即是有序的，首先不可拆时（一个元素）是有序的，两个数组合并为一个有序的大数组，再作为下一次的小数组与其它有序小数组合并，最终归到根节点，数组合并完成，元素即是有序的。<br>如图，黑色为递的过程，将数据拆分，红色是归和并的过程，将有序的小数组合并为有序的大数组，最终将所有数据排序完成。<br><img src="https://img.yangrunwei.com/article-img/20200711/51fab016-5f2e-4d0a-9049-0b785daeb289--%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序" title="归并排序"><br>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.mergeSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        self.mergeSort(nums, left, mid)</span><br><span class="line">        self.mergeSort(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">        self.merge(nums, left, right, mid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums, left, right, mid</span>):</span><br><span class="line">        tmp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left + <span class="number">1</span>)]</span><br><span class="line">        i = left</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">                tmp[k] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[k] = nums[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">            nums[left + p] = tmp[p]</span><br></pre></td></tr></table></figure>

<h2 id="归并排序求逆序对"><a href="#归并排序求逆序对" class="headerlink" title="归并排序求逆序对"></a>归并排序求逆序对</h2><p>相应的题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a><br>对于统计逆序对数量，在归并的merge其实已经实现了，它会对比两个子数组元素的大小，这时可以统计左边数组元素比右边数组大的情况的数量。<br>有两种统计方法：</p>
<ol>
<li>在左边元素小于或等于右边的时候统计，这时表明左边元素大于右边的右侧元素，且需要在右边元素多的情况下，再统计多一次；</li>
<li>在左边元素大于右边的时候统计，这时表明左边左侧元素比右边这个元素大，增加逆序对数量；<br>这里采用第2种方法，实现比较简洁。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.countBymergeSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBymergeSort</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.countBymergeSort(nums, left, mid) + self.countBymergeSort(nums, mid + <span class="number">1</span>, right) + self.merge(nums, left, right, mid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums, start, end, mid</span>):</span><br><span class="line">        i = start</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        tmp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(end - start + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">                tmp[k] = nums[i]</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += (mid - i + <span class="number">1</span>)</span><br><span class="line">                tmp[k] = nums[j]</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">            nums[start + p] = tmp[p]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h2 id="求解开篇题目"><a href="#求解开篇题目" class="headerlink" title="求解开篇题目"></a>求解开篇题目</h2><p>逆序的统计方法有了，现在离开篇题目只差一点了，因为前面的方法只是统计整个数组中逆序的数量，但开篇题目要求的是每个元素与其后面元素对比，逆序的数量。归并的时候其实是将每个元素与其后面元素的逆序数量累加起来，所以基本是符合要求的，只是排序之后元素可能与之前的位置不同，没办法对应到counts位置上。这时可以利用“索引数组”，实际排序的是该数组，对比是用的是索引对应的原数组的值。<br>举个“索引数组”在归并排序中的例子，如图所示：<br><img src="https://img.yangrunwei.com/article-img/20200712/df6eb742-1fca-457f-9635-970d8b1e2bb7--%E7%B4%A2%E5%BC%95%E6%95%B0%E7%BB%84.jpg" alt="索引数组" title="索引数组"></p>
<p>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">归并排序 + 索引数组</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        indexes = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        res = [<span class="number">0</span>] * size</span><br><span class="line">        self.countByMergeSort(nums, <span class="number">0</span>, size - <span class="number">1</span>, indexes, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countByMergeSort</span>(<span class="params">self, nums, left, right, indexes, res</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        self.countByMergeSort(nums, left, mid, indexes, res)</span><br><span class="line">        self.countByMergeSort(nums, mid + <span class="number">1</span>, right, indexes, res)</span><br><span class="line">        </span><br><span class="line">        self.merge(nums, left, right, mid, indexes, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums, left, right, mid, indexes, res</span>):</span><br><span class="line">        tmp = [<span class="number">0</span>] * (right - left + <span class="number">1</span>)</span><br><span class="line">        i = left</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[indexes[i]] &lt;= nums[indexes[j]]:</span><br><span class="line">                tmp[k] = indexes[i]</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                res[indexes[i]] += j - mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[k] = indexes[j]</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">            tmp[k] = indexes[i]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            res[indexes[i]] += right - mid</span><br><span class="line">        <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">            tmp[k] = indexes[j]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">            indexes[left + p] = tmp[p]</span><br></pre></td></tr></table></figure>


</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/112.html">一致性Hash算法原理及代码实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h1><p>一致性Hash算法主要应用在缓存均衡上。</p>
<h2 id="传统Hash算法"><a href="#传统Hash算法" class="headerlink" title="传统Hash算法"></a>传统Hash算法</h2><p>将节点转为数值，对实例数量取余数的方式。<br>缺点：增减节点，会影响全局的缓存分配，降低缓存命中率，减弱了缓存的作用，导致系统稳定性、可用性降低。</p>
<h2 id="一致性Hash原理及优点"><a href="#一致性Hash原理及优点" class="headerlink" title="一致性Hash原理及优点"></a>一致性Hash原理及优点</h2><p><img src="https://img.yangrunwei.com/article-img/20200707/c8a26ad6-2dd8-4296-83a1-54bdce5977b5--20161125012754024.jpg"></p>
<p>节点分配到2^32长度的环上，缓存值对应到环上时，通过顺时针找到最近的节点。<br>优点：解决传统Hash导致的增减节点缓存迁移的问题，一致性Hash只影响局部的缓存节点。<br>缺点：节点过少时，可能没能均匀地分配到环上，导致缓存不均衡，部分节点压力过大，而且增加节点没办法分担系统整体的负载，因为只能降低新节点顺时针最近的节点负载，对其它节点的负载没有优化，达不到水平扩容的效果。</p>
<h2 id="一致性Hash虚拟节点"><a href="#一致性Hash虚拟节点" class="headerlink" title="一致性Hash虚拟节点"></a>一致性Hash虚拟节点</h2><p>可以通过虚拟节点的方式，解决环上节点分配不均匀，及水平扩容问题。<br>每个实际的节点虚拟出若干个节点，分配到环上。</p>
<p><img src="https://img.yangrunwei.com/article-img/20200708/27bdce9d-ca06-42d8-bb26-14fb67f950b2--%E5%9B%BE%E7%89%87.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> assert <span class="keyword">from</span> <span class="string">&#x27;assert&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsistencyHash</span> &#123;</span><br><span class="line">    private servers = []</span><br><span class="line"></span><br><span class="line">    public <span class="title function_">addServer</span>(<span class="params">s: string, virtualNodesNum: number</span>) &#123;</span><br><span class="line">        <span class="title function_">assert</span>(virtualNodesNum &gt; <span class="number">0</span>, <span class="string">`virtualNodesNum &gt; 0`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; virtualNodesNum; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> hashCode = <span class="variable language_">this</span>.<span class="title function_">_getHashCode</span>(<span class="string">`<span class="subst">$&#123;s&#125;</span>-vi-<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">servers</span>.<span class="title function_">push</span>(&#123; s, <span class="attr">h</span>: hashCode &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">servers</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">p, n</span>) =&gt;</span> p.<span class="property">h</span> - n.<span class="property">h</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="title function_">getServerForValue</span>(<span class="params">value: string</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> hashCode = <span class="variable language_">this</span>.<span class="title function_">_getHashCode</span>(value)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">servers</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashCode &lt;= v.<span class="property">h</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> v.<span class="property">s</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">servers</span>[<span class="number">0</span>].<span class="property">s</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32位的 Fowler-Noll-Vo 哈希算法</span></span><br><span class="line">    <span class="comment">// https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function</span></span><br><span class="line">    private <span class="title function_">_getHashCode</span>(<span class="params">key: string</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hash = <span class="number">0x811C9DC5</span> <span class="comment">/* offset_basis */</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(key)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            hash = hash ^ data[i]</span><br><span class="line">            <span class="comment">/* 32 bit FNV_Prime = 2**24 + 2**8 + 0x93 */</span></span><br><span class="line">            hash += (hash &lt;&lt; <span class="number">24</span>) + (hash &lt;&lt; <span class="number">8</span>) + (hash &lt;&lt; <span class="number">7</span>) + (hash &lt;&lt; <span class="number">4</span>) + (hash &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        hash = hash &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">return</span> hash &gt; <span class="number">0</span> ? hash : <span class="title class_">Math</span>.<span class="title function_">abs</span>(hash)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    private hash = <span class="keyword">new</span> <span class="title class_">ConsistencyHash</span>()</span><br><span class="line">    public <span class="title function_">run</span>(<span class="params">virtualNodesNum: number</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> servers = [</span><br><span class="line">            <span class="string">&#x27;192.168.1.0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.2&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.3&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.5&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.6&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.7&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;192.168.1.9&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> servers) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">hash</span>.<span class="title function_">addServer</span>(s, virtualNodesNum)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> total = <span class="number">100</span> * <span class="number">10000</span></span><br><span class="line">        <span class="keyword">const</span> values = <span class="title class_">Array</span>(total).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i.<span class="title function_">toString</span>())</span><br><span class="line">        <span class="keyword">const</span> serversOfCount = <span class="title class_">Array</span>(servers.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> values) &#123;</span><br><span class="line">            <span class="keyword">const</span> s = <span class="variable language_">this</span>.<span class="property">hash</span>.<span class="title function_">getServerForValue</span>(v)</span><br><span class="line">            serversOfCount[servers.<span class="title function_">indexOf</span>(s)] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标准差：sqrt((节点被hash到的数量-平均值)**2/服务器数量)</span></span><br><span class="line">        <span class="keyword">const</span> svg = total / servers.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> serversOfCount) &#123;</span><br><span class="line">            sum += <span class="title class_">Math</span>.<span class="title function_">pow</span>((c - svg), <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(sum / servers.<span class="property">length</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`虚拟节点数：<span class="subst">$&#123;virtualNodesNum&#125;</span>，标准差：<span class="subst">$&#123;res&#125;</span>\n`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>()</span><br><span class="line">    test.<span class="title function_">run</span>(<span class="number">1</span>)</span><br><span class="line">    test.<span class="title function_">run</span>(<span class="number">5</span>)</span><br><span class="line">    test.<span class="title function_">run</span>(<span class="number">100</span>)</span><br><span class="line">    test.<span class="title function_">run</span>(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure>

<h4 id="测试用例的结果："><a href="#测试用例的结果：" class="headerlink" title="测试用例的结果："></a>测试用例的结果：</h4><p>虚拟节点数：1，标准差：90297.65832954917</p>
<p>虚拟节点数：5，标准差：88019.59732468674</p>
<p>虚拟节点数：100，标准差：75327.12365144445</p>
<p>虚拟节点数：200，标准差：50203.197645169974</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/111.html">嵌套、扁平菜单互转</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><p>今天被一个简单的嵌套、扁平菜单转换问题搞懵，特此记录一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">const assert = require(&#x27;assert&#x27;)</span><br><span class="line"></span><br><span class="line">// 扁平菜单</span><br><span class="line">const flatMenu = [</span><br><span class="line">    &#123;</span><br><span class="line">        id: 13,</span><br><span class="line">        name: &quot;菜单3&quot;,</span><br><span class="line">        parent: 12,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        name: &quot;菜单1&quot;,</span><br><span class="line">        parent: null,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 12,</span><br><span class="line">        name: &quot;菜单2&quot;,</span><br><span class="line">        parent: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        name: &quot;菜单1-1&quot;,</span><br><span class="line">        parent: null,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 14,</span><br><span class="line">        name: &quot;菜单3-1&quot;,</span><br><span class="line">        parent: 12,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 嵌套菜单</span><br><span class="line">const nestMenu = [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;name&quot;: &quot;菜单1&quot;,</span><br><span class="line">        &quot;parent&quot;: null,</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 12,</span><br><span class="line">                &quot;name&quot;: &quot;菜单2&quot;,</span><br><span class="line">                &quot;parent&quot;: 1,</span><br><span class="line">                &quot;children&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: 13,</span><br><span class="line">                        &quot;name&quot;: &quot;菜单3&quot;,</span><br><span class="line">                        &quot;parent&quot;: 12,</span><br><span class="line">                        &quot;children&quot;: []</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: 14,</span><br><span class="line">                        &quot;name&quot;: &quot;菜单3-1&quot;,</span><br><span class="line">                        &quot;parent&quot;: 12,</span><br><span class="line">                        &quot;children&quot;: []</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 2,</span><br><span class="line">        &quot;name&quot;: &quot;菜单1-1&quot;,</span><br><span class="line">        &quot;parent&quot;: null,</span><br><span class="line">        &quot;children&quot;: []</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 扁平转嵌套</span><br><span class="line">class FlatToNest &#123;</span><br><span class="line">    entry(menuList) &#123;</span><br><span class="line">        const res = []</span><br><span class="line">        const map = &#123;&#125;</span><br><span class="line">        for (const node of menuList) &#123;</span><br><span class="line">            node.children = []</span><br><span class="line">            map[node.id] = node</span><br><span class="line">        &#125;</span><br><span class="line">        for (const node of menuList) &#123;</span><br><span class="line">            if (node.parent) &#123;</span><br><span class="line">                map[node.parent].children.push(node)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.push(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 嵌套转扁平</span><br><span class="line">class NestToFlat &#123;</span><br><span class="line">    entry(menuList) &#123;</span><br><span class="line">        let res = []</span><br><span class="line">        for (const node of menuList) &#123;</span><br><span class="line">            res = res.concat(this.entry(node.children))</span><br><span class="line">            res.push(node)</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">class FlatToNestTest &#123;</span><br><span class="line">    run() &#123;</span><br><span class="line">        const res = (new FlatToNest()).entry(flatMenu)</span><br><span class="line">        assert.deepStrictEqual(res, nestMenu)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NestToFlatTest &#123;</span><br><span class="line">    run() &#123;</span><br><span class="line">        const res = (new NestToFlat()).entry(nestMenu)</span><br><span class="line">        assert.deepStrictEqual(res.sort((p, n) =&gt; p.id - n.id), flatMenu.sort((p, n) =&gt; p.id - n.id))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">    (new FlatToNestTest()).run();</span><br><span class="line">    (new NestToFlatTest()).run();</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/110.html">算法现学现卖—— 单调栈</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="结构特性"><a href="#结构特性" class="headerlink" title="结构特性"></a>结构特性</h2><ul>
<li>先入后出</li>
<li>入栈的数据满足单调递增或递减</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果要在一个非负整数数组里求解某个整数左右边界（即左右两边第一个小于当前元素值的元素），一般情况下需要不断向左右两边遍历查找，是O(n^2)的时间复杂度。如果使用单调递增栈，则能缓存左边界的值，随着元素不断入栈，不满足递增特性的值即是右边界，时间复杂度为O(n)。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="https://img.yangrunwei.com/article-img/20200530/862e9f58-2ea5-4cde-975e-77280cf8a1f3--largest-rectangle-in-histogram.jpg"></p>
</blockquote>
<p>以图中的柱图为例，我们要求位置为2高度为5的柱子所能构成的最大面积。其左边第一个高度小于5的柱子位置为1高度为1，右边第一个高度小于5的柱子位置4高度 2，假设heights表示柱子高度的数组，左右边界的位置分别是left和right，所以其最大面积为heights[2]*(right-left-1) &#x3D; 5 * (4-1-1) &#x3D; 10<br><img src="https://img.yangrunwei.com/article-img/20200530/ddc69660-5db7-41e5-baff-74922cfa6baa--%E8%BE%B9%E7%95%8C%E5%8F%8A%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.jpg"></p>
<p>明确了计算的方法，我们就只差怎样确定柱子左右边界了。<br>利用单调递增栈的特性，对元素进行入栈操作，如果高度满足递增要求，则直接入栈，若柱子高度小于栈顶柱子高度，则该柱子为栈顶柱子的右边界，而栈顶柱子在栈内的左边第一个柱子为其左边界，此时就确定了两个边界了。<br>计算完栈顶柱子的最大面积，需要将其出栈，待入栈的柱子继续去新的栈顶柱子比较。</p>
<p><img src="https://img.yangrunwei.com/article-img/20200530/bb6e68a9-d87f-4233-812f-df03252919fd--%E5%8D%95%E8%B0%83%E6%A0%88%E8%BF%87%E7%A8%8B.jpg"></p>
<p>此时可能有读者想到，如果柱子高度的数组本来就是单调递增的，那就只是一直入栈，并没有出栈计算面积的时候。此时可以在柱子遍历完成后判断栈是否为空，不为空则强制出栈，此时右边界相当于是高度为0的柱子。<br>另外还有柱子高度的数组是单调递减的情况，即一直是出栈，栈顶找不到其栈内左边的元素。<br>为了简化编码流程，可以采用更巧妙的哨兵机制，即在原始柱子调度数组首尾加上0，即高度为0的柱子，即不影响面积的计算，又能兼容上述情况。</p>
<p><img src="https://img.yangrunwei.com/article-img/20200530/aa6743e7-1057-4e63-a46e-792205dda3d6--%E5%93%A8%E5%85%B5%E5%8D%95%E8%B0%83%E6%A0%88.jpg"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestRectangleArea(self, heights: List[int]) -&gt; int:</span><br><span class="line">        heights = [0]+heights+[0]</span><br><span class="line">        stack = []</span><br><span class="line">        res = 0</span><br><span class="line">        for i in range(len(heights)):</span><br><span class="line">            while stack and heights[stack[-1]] &gt; heights[i]:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res = max(res, heights[cur]*(i-stack[-1]-1))</span><br><span class="line">            stack.append(i)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/109.html">算法现学现卖—— 有趣的位运算（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h2 id="有趣的位运算-——-异或排除重复的元素"><a href="#有趣的位运算-——-异或排除重复的元素" class="headerlink" title="有趣的位运算 —— 异或排除重复的元素"></a>有趣的位运算 —— 异或排除重复的元素</h2><ul>
<li>leetcode 136. 只出现一次的数字<blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
</blockquote>
<p>示例1：<br>输入: [2,2,1]<br>输出: 1</p>
<blockquote>
</blockquote>
<p>示例 2:<br>输入: [4,1,2,1,2]<br>输出: 4</p>
</li>
</ul>
<p>该题想让我们找出数组里的唯一元素，直觉上我们会使用哈希表，将重复的元素记录下来判断，但哈希表会占用额外的内存空间，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        h = defaultdict(int)</span><br><span class="line">        res = 0</span><br><span class="line">        for n in nums:</span><br><span class="line">            h[n] += 1</span><br><span class="line">            if h[n] &gt; 1:</span><br><span class="line">                res -= n</span><br><span class="line">            else:</span><br><span class="line">                res += n</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>如果用位运算异或，将重复元素排除，即可找出不重复的元素了，用异或的原因是：</p>
<ol>
<li>任何数与0异或得到自身；</li>
<li>任何数与自身异或得到0；</li>
<li>异或满足结合律；</li>
</ol>
<p>则最终实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        res = 0</span><br><span class="line">        for n in nums:</span><br><span class="line">            res ^= n</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p>这时候是常量级别的空间复杂度。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/108.html">算法现学现卖—— 滑动窗口</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>滑动窗口，高级指针编程技巧，可以用于判断数组、链表、字符串等线性结构的子结构问题。</p>
<p>编程过程中，用左右指针形成的区间作为窗口，对窗口中的子结构进行判断，然后扩展右指针或缩小左指针，最终遍历完整个数据，窗口也记录下所有满足条件的子结构。</p>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">left, right = 0, 0</span><br><span class="line">window = []</span><br><span class="line">while right &lt; size:</span><br><span class="line">	right += 1</span><br><span class="line">	window.append(right)</span><br><span class="line">	while valid:</span><br><span class="line">		window.pop(0)</span><br><span class="line">		left += 1</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>left,right是窗口的左右边界，分别从0开始向右移动，window记录窗口各字符的数量，res记录窗口历史最大长度；</li>
<li>right不断移动，如果出现window中字符数量大于1，则移动left，直到该字符数量为1，更新res；</li>
<li>重复2，直到right遍历到字符串末尾，返回res<br><img src="https://img.yangrunwei.com/article-img/20200502/f5b4b4fd-b5da-4d7e-b076-f73170919c2d--%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg"></li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        left, right = 0, 0</span><br><span class="line">        res = 0</span><br><span class="line">        window = collections.defaultdict(int)</span><br><span class="line">        while right &lt; len(s):</span><br><span class="line">            rc = s[right]</span><br><span class="line">            window[rc] += 1</span><br><span class="line">            right += 1</span><br><span class="line">            while window[rc] &gt; 1:</span><br><span class="line">                lc = s[left]</span><br><span class="line">                window[lc] -= 1</span><br><span class="line">                left += 1</span><br><span class="line">            res = max(res, right - left)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7.md">滑动窗口技巧</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By 杨润炜</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>