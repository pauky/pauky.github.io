<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="杨润炜"><meta name="copyright" content="杨润炜"><title>Cwalker</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">杨润炜</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">137</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cwalker</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Cwalker</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/a/107.html">《编码——隐匿在计算机软硬件背后的语言》笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/read/">read</a></span><div class="content"><p>在看计组资料时，经常看到有人推荐或引用此书，一直挺好奇，这段时间终于断断续续地翻完，简单地做一下回顾和总结。</p>
<p>首先它内容生动有趣，不会让你感到枯燥，这也得益于作者的思维活跃，善于把科学的东西生动化；<br>其次它并不只是表面上介绍一些有哪些技术的科普读物，有一定的深度，对于想学习计组的同学是本入门的好书；<br>给我印象最深的内容是书中对数字系统的讲述，我看完还跟女友描述了一番，觉得又对熟悉的世界有了一番新认识。我这里“剧透”一点点，书中对于我们使用的数字系统——阿拉伯数字系统 进行描述，它是用进位来实现计算的，对比罗马数字系统，计算方式更合理，也正是如此，二进制也是用位的方式来计算。具体需要在书中从头看起，作者很会铺垫，读起来会更有趣；<br>最让人蠢蠢欲动的，要数作者展示的如何用电灯、开头、电线构建一台“计算机”的过程，本质跟现代计算机是相通的，不过在书后面会看到现代计算机高级的地方 —— 指令，特别是循环、条件指令，是软件的基础；<br>逻辑学、布尔代数、门电路、触发器、计算机，这种从理论到实体的推进式描述，是最让我感触的地方，我似乎见证到计算机从摇篮逐步成长起来的过程；<br>后面的微机原理、操作系统会稍微浅一些，主要还是些背景、历史介绍居多，浮点数、定点数的讲述很好，看了会对计算机对数字和计算的过程有更深的了解。</p>
<p>下图是我看书的笔记，仅仅是记录一下，不太严谨。<br><img src="https://yrw-blog.oss-cn-shenzhen.aliyuncs.com/article-img/20200426/08820f2a-3898-42c1-a5aa-4267f4b20469--Code.jpg"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/106.html">算法现学现卖—— 回溯算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul>
<li>如果理解了递归、DFS，那么理解回溯就很简单了，它就是在递归的每一层处理完成后，将其造成的影响抹去，上一层就像没事发生一样，继续运行其它层的逻辑</li>
<li>如果大家看过《蝴蝶效应》（没看的抓紧啦）都知道里面的主角能够回到过去更改某一时刻的决定，这个过程就是回溯，回到过去再做另外的决定。</li>
</ul>
<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dfs (level, params):</span><br><span class="line">    <span class="comment"># 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> level &gt;= max_level:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    do_something()</span><br><span class="line">    <span class="comment"># 下探到下一层</span></span><br><span class="line">    dfs(level + <span class="number">1</span>, params)</span><br><span class="line">	<span class="comment"># 撤消当前的影响，以便回溯</span></span><br><span class="line">	revert_current_status()</span><br></pre></td></tr></table></figure>

<h2 id="例题解析"><a href="#例题解析" class="headerlink" title="例题解析"></a>例题解析</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">全排列</a></p>
<h3 id="先来看递归不回溯的形式"><a href="#先来看递归不回溯的形式" class="headerlink" title="先来看递归不回溯的形式"></a>先来看递归不回溯的形式</h3><p><img src="https://yrw-blog.oss-cn-shenzhen.aliyuncs.com/article-img/20200425/76d17bee-188e-4fde-9692-8237bf4f6654--123.jpg"><br>每次都从可选数字里选择当前节点数组里不存在的元素，然后继续下一层，直到数组元素个数为3，详情请看代码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(nums, res, [])</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res <span class="keyword">else</span> [res]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, nums, res, item</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(item) &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> res.append(item)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> item:</span><br><span class="line">                self.dfs(nums, res, item + [k])</span><br></pre></td></tr></table></figure>

<h3 id="再看看回溯的方式"><a href="#再看看回溯的方式" class="headerlink" title="再看看回溯的方式"></a>再看看回溯的方式</h3><p><img src="https://yrw-blog.oss-cn-shenzhen.aliyuncs.com/article-img/20200425/8db5e4f4-4d81-482d-8ac9-9aa25aa4855c--aaa.jpg"><br>红色线代表撤消操作，如[1,2]撤消为[1]，然后按递归顺序深度优先地运行下去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(nums, res, [])</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res <span class="keyword">else</span> [res]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, nums, res, item</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(item) &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> res.append(item[:])</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> item:</span><br><span class="line">                item.append(k)</span><br><span class="line">                self.dfs(nums, res, item)</span><br><span class="line">                item.pop()</span><br></pre></td></tr></table></figure>

<p>回溯的方式主要是多了item的pop操作，它的作用是恢复该层对数据的影响，这样整个过程就复用一个item列表，节省了空间</p>
<h2 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">全排列</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">N皇后</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/105.html">算法现学现卖—— 递归 and DFS</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="递归-and-DFS"><a href="#递归-and-DFS" class="headerlink" title="递归 and DFS"></a>递归 and DFS</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul>
<li>要了解DFS，首先要了解递归，它一般用来解决重复性问题，而且形式十分简洁，比如树的遍历、DFS。</li>
<li>DFS字面上的意思也就是它的实际意义和主要应用场景，深度优先搜索。运行的过程就像是遍历树的过程，每一次从根节点出发，遍历完子树再回到父节点，递归重复这个过程就可以遍历完整棵树，也就完成了深度优先搜索。</li>
</ul>
<p>有两个比较形象的方式理解递归：</p>
<ul>
<li>想必大家都看过《盗梦空间》吧（没有的就有借口看看啦），可以把递归的过程想象成盗梦空间里进入别人梦境的过程，每一层的环境都是独立的，而且主角可以通过探到下一层把信息带到上层；</li>
<li>另外一个是生活中看电影的场景，如果你在看电影的时候想知道自己坐在第几排（假设电影院里太黑，大家都看不到座位号，哈哈），这时你可以问你前一排，前一排再问他的前一排，一直到第一排（第一排没有前排了，所以自然知道自己在第一排），就回复说自己在第一排，然后第二排也知道了，反方向将信息传递回来，每一层都知道了自己的排号，直到传到最上层。我们把向下问的过程叫“递”，把回复的过程叫“归”。</li>
</ul>
<p>我们以二叉树的前序遍历为例，展示深度优先搜索的递归过程，如下图：<br><img src="https://yrw-blog.oss-cn-shenzhen.aliyuncs.com/article-img/20200425/7f1934eb-0af5-480e-aa38-52560f9cbc37--%E6%A0%91.jpg"></p>
<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="递归形式，利用系统给我们维护的栈"><a href="#递归形式，利用系统给我们维护的栈" class="headerlink" title="递归形式，利用系统给我们维护的栈"></a>递归形式，利用系统给我们维护的栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dfs (level, params):</span><br><span class="line">	<span class="comment"># 递归终止条件</span></span><br><span class="line">	<span class="keyword">if</span> level &gt;= max_level:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	do_something()</span><br><span class="line">	<span class="comment"># 下探到下一层</span></span><br><span class="line">	dfs(level + <span class="number">1</span>, params)</span><br></pre></td></tr></table></figure>

<h3 id="自定义栈"><a href="#自定义栈" class="headerlink" title="自定义栈"></a>自定义栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">	<span class="comment"># 栈顶元素出栈</span></span><br><span class="line">	current_node = stack.pop()</span><br><span class="line">	do_something()</span><br><span class="line">	<span class="comment"># 将子节点入栈</span></span><br><span class="line">	<span class="keyword">if</span> current_node.child:</span><br><span class="line">		stack.append(current_node.child)</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">N叉树的前序遍历</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">N叉树的后序遍历</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/104.html">算法现学现卖——BFS</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><ul>
<li>广度优先遍历；</li>
<li>从根节点出发，向外一圈圈扩散地遍历，可以想像水波一样一圈圈向外扩散；</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/0ef5121d0b1b70d60967e0f8081df945dbbca0a4b8fff26b8ca0e09c649e9210.jpg"></p>
<h2 id="求最短or最远距离"><a href="#求最短or最远距离" class="headerlink" title="求最短or最远距离"></a>求最短or最远距离</h2><ul>
<li>最短距离：利用广度优先的扩散式遍历的特点，当a扩散到b时，两点的距离就是遍历的层数；</li>
<li>最远距离：最后遍历到的节点的层数；</li>
<li>单源BFS适用找树，多源BFS适用搜图，因为树是有方向的，图可能有环路，所以用多源时需要判断节点是否被访问过，防止死循环</li>
</ul>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>():</span><br><span class="line">    distance = <span class="number">0</span> <span class="comment"># 距离</span></span><br><span class="line">    queue = [start]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        distance += <span class="number">1</span></span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="comment"># 遍历同一层的节点</span></span><br><span class="line">        <span class="keyword">while</span> size:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> is_end():</span><br><span class="line">                <span class="keyword">return</span> distance</span><br><span class="line">            <span class="comment"># 节点访问判重，可以将访问过的节点存起来判断，也可以改变节点的值标识已被访问，这样可以节省空间</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited:</span><br><span class="line">                queue.append(new_node)</span><br><span class="line">            size -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="对应的题目"><a href="#对应的题目" class="headerlink" title="对应的题目"></a>对应的题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/01-matrix/">01矩阵</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">地图分析</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/pauky/leetcode-solution">更多算法题解与总结</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/103.html">ssh隧道实现内网穿透</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/linux/">linux</a></span><div class="content"><p><img src="https://yrw-blog.oss-cn-shenzhen.aliyuncs.com/article-img/20200117/64da1253-ec1c-48c3-af96-fd2794322ead--ssh%E9%9A%A7%E9%81%93%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.jpg" alt="ssh隧道实现内网穿透" title="ssh隧道实现内网穿透"></p>
<h2 id="内网穿透的应用场景"><a href="#内网穿透的应用场景" class="headerlink" title="内网穿透的应用场景"></a>内网穿透的应用场景</h2><p>客户的机器在内网环境，外部无法直接远程登录过去，但我们又想远程协助对方。如图中虚线的远程方式。<br>这时可以让客户那边一台可以访问外网的机器B与我们的公网机器建立远程ssh隧道，然后个人电脑再通过公网机器跳转到客户机器B，再通过内网登录机器A进行操作。</p>
<h2 id="为什么用ssh隧道？"><a href="#为什么用ssh隧道？" class="headerlink" title="为什么用ssh隧道？"></a>为什么用ssh隧道？</h2><p>相对市面上的远程协作工具，在网速慢的情况下使用命令行会更流畅，虽然远程协作可以命令行，但ssh隧道更简便，操作更简便，跨平台兼容很好。而且ssh还有加密的功能，整体上也更加安全、稳定、可控。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="开启公网机房机器的ssh网关转发功能"><a href="#开启公网机房机器的ssh网关转发功能" class="headerlink" title="开启公网机房机器的ssh网关转发功能"></a>开启公网机房机器的ssh网关转发功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config; </span><br></pre></td></tr></table></figure>
<p>GatewayPorts改为yes；然后重启生效sshd服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart sshd；</span><br></pre></td></tr></table></figure>

<h3 id="建立ssh隧道"><a href="#建立ssh隧道" class="headerlink" title="建立ssh隧道"></a>建立ssh隧道</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -NR 0.0.0.0:32222:localhost:22 公网机房机器用户名@219.136.74.12 -v</span><br></pre></td></tr></table></figure>
<p>这时会在公网机房机器上开启32222端口，并将其数据代理到客户B机器的22端口；</p>
<h3 id="个人电脑登录客户B机器"><a href="#个人电脑登录客户B机器" class="headerlink" title="个人电脑登录客户B机器"></a>个人电脑登录客户B机器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 32222 客户B机器的用户名@10.0.2.12</span><br></pre></td></tr></table></figure>

<h3 id="登录客户A机器"><a href="#登录客户A机器" class="headerlink" title="登录客户A机器"></a>登录客户A机器</h3><p>使用客户B的ssh直接登录过去</p>
<h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>在个人电脑上拷贝文件到客户B机器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 32222  your_file 客户B机器的用户名@10.0.2.12:target_path</span><br></pre></td></tr></table></figure>
<p>将your_file拷贝到客户B机器的target_path目录下</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果客户B机器是台mac个人电脑，如果在开启远程登录功能，在“系统偏好设置” &#x3D;&#x3D; “共享” &#x3D;&#x3D; 勾选“远程登录”，可选择所有用户或指定用户</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/102.html">《深入浅出计算机组成原理》 思维导图笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/geekbang/">geekbang</a></span><div class="content"><p>学习极客时间的《深入浅出计算机组成原理》所整理的笔记内容</p>
<p><img src="https://yrw-blog.oss-cn-shenzhen.aliyuncs.com/article-img/20200102/11fb7189-8815-447b-8063-b129e3eb5943--%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.png" alt="计算机组成原理" title="计算机组成原理"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/101.html">《斗破苍穹》读后感</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/life/">life</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/read/">read</a></span><div class="content"><p>看完这部小说的事已经过去了两个月，今天突然想起要给自己第一次完整看完的长篇小说《斗破苍穹》写个读后感。看书的时候，故事总能激起内心热血的一面，同时我也很敬佩他，因为他总能不断突破自己。可能是最近对于自我提升的迫切感和焦虑感，让我又想起了小说里特别拼的主角萧炎。他是怎样一步步走向成长并最终到达巅峰的呢？</p>
<p>我觉得主角能成神，除了因为有主角光环之外，还有以下几点原因：</p>
<h4 id="一波接一波的推动力，逼他不断地提升自己；"><a href="#一波接一波的推动力，逼他不断地提升自己；" class="headerlink" title="一波接一波的推动力，逼他不断地提升自己；"></a>一波接一波的推动力，逼他不断地提升自己；</h4><p>小时候因为“失去”天赋，周围人的嘲笑成为他不断修炼的动力；<br>婚约被毁，失去了最后尊严的他，只能破釜沉舟立下三年之约，他便靠着这股劲走遍了大半个帝国，每天只记得修炼，只想拿回尊严，他几乎是凭着这动物本性，一人对抗当时帝国最大势力——云岚宗；<br>本来打赢了三年之约，打算平淡地过一生，小说也可以完毕。没想到老爹、恩师被魂殿抓走了，他不得不对抗这股在大陆上人人畏惧的势力，修炼又不能停下了，而且还要比以前更努力，因为对手太强太强了；<br>后来，迦南学院的同龄学生竞争，到大陆中心强者的接连追杀，为了保护自己、保护自己在乎的人，只能是不断折腾，一刻也不能停。<br>在整部小说里，主角几乎就是处于这种被动状态，接连不断的推动力、压力落在身上，逼着他向前走。</p>
<h4 id="分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；"><a href="#分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；" class="headerlink" title="分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；"></a>分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；</h4><p>在小说里，有很多人是通过吃药或各种捷径来取得提升的，主角也有很多机会可以得到，几乎唾手可得，但他却放弃了，明明他的焦虑感是最重的，却能踏踏实实一阶阶地修炼提升。总感觉这是个bug，现实中大家都想“偷懒”，少走点路少做点事，按部就班都被当成奇葩了。偏偏主角就是个奇葩。</p>
<h4 id="目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；"><a href="#目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；" class="headerlink" title="目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；"></a>目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；</h4><p>小说里的美女，没有哪一个不跟主角眉来眼去的。英雄难过美人关，主角居然不买帐，这也是个bug吧。不过主角确实不觉得自己是救世主或英雄，他只是在做一件平常的事，保护自己、保护在乎的人。这种一根筋的人，确实没办法被色诱的吧。就算是给他一打绝色美女，又或者是整个帝国，都始终没能动摇他对目标的坚持。</p>
<h4 id="不逞英雄，相信团队；"><a href="#不逞英雄，相信团队；" class="headerlink" title="不逞英雄，相信团队；"></a>不逞英雄，相信团队；</h4><p>主角在迦南学院学到的最重要的技能，就是“拉帮结派”。他开始意识到一个人能力有限，得借助并相信队友，组建团队才能走得更远。随着建立磐门到萧门到炎盟到天府盟，他随着团队的壮大，自身的提升速度和能提升到的最大点也不断增大。</p>
<h4 id="最后，最重要的一点：局势造就英雄；"><a href="#最后，最重要的一点：局势造就英雄；" class="headerlink" title="最后，最重要的一点：局势造就英雄；"></a>最后，最重要的一点：局势造就英雄；</h4><p>如果没有魂殿的阴谋，没有他企图毁灭整个中洲的大背景，主角应该到死还在家当掌柜卖药材吧。</p>
<p>以上就是我认为主角为什么能走向巅峰的原因。这些原因也是我最近对于如何学习的一些看法。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/100.html">极客时间官方21天打卡行动第一期</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/geekbang/">geekbang</a></span><div class="content"><h1 id="极客时间上的21天打卡"><a href="#极客时间上的21天打卡" class="headerlink" title="极客时间上的21天打卡"></a>极客时间上的21天打卡</h1><p>立个flag，完成极客时间的21天打卡行动（完结）。</p>
<p>从 2019-12-19 到 2020-01-08 连续21天不间断打卡，即使中间有时候遇到很忙碌的情况，还是会想着学习一会打个卡，而且慢慢会养成固定时间学习的习惯。虽然21天学习下来知识没怎么涨，但习惯的养成估计更有价值。希望这次“跨年之战”的热情和精神能继续发扬，最终形成自己的学习习惯。</p>
<h2 id="第二十一天（2020-01-08）："><a href="#第二十一天（2020-01-08）：" class="headerlink" title="第二十一天（2020-01-08）："></a>第二十一天（2020-01-08）：</h2><p>《数据结构与算法之美》</p>
<p>学习了跳表这种数据结构。跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)；</p>
<p>如果链表节点有变动，需要动态更新多级索引来维持跳表的“平衡性”，一般是通过随机函数实现的，从概率上能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化；</p>
<p>redis的有序集合就是用跳表实现的；</p>
<p>跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p>
<h2 id="第二十天（2020-01-07）："><a href="#第二十天（2020-01-07）：" class="headerlink" title="第二十天（2020-01-07）："></a>第二十天（2020-01-07）：</h2><p>《数据结构与算法之美》</p>
<p>二分查找是一种非常高效的查找算法，O(logn)对数时间复杂度，比如在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次，极其高效；</p>
<p>二分查找应用场景的局限性：<br>二分查找依赖的是顺序表结构，简单点说就是数组；<br>二分查找针对的是有序数据；<br>数据量太小或太大不适合二分查找，太小不必要用这么复杂的算法，太大又会占用太多连续内存空间；<br>二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作；</p>
<p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p>
<h2 id="第十九天（2020-01-06）："><a href="#第十九天（2020-01-06）：" class="headerlink" title="第十九天（2020-01-06）："></a>第十九天（2020-01-06）：</h2><p>《数据结构与算法之美》<br>哪种排序算法适合用来做通用的排序函数？<br>线性排序的适用场景比较严格，不够通用；<br>复杂度为O(n2)适用小规模数据集，不够通用；<br>剩下时间复杂度是 O(nlogn)的归并和快速排序，但归并不是原地排序，数据多了会占用更多的内存，所以快速排序比较适合来实现排序函数；</p>
<p>如何优化快速排序？<br>因为快速排序的最坏情况时间复杂度是O(n2)，需要想办法优化。<br>O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理；<br>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p>
<p>两个比较常用、比较简单的分区算法：<br>三数取中法；<br>随机法；</p>
<p>防止快速排序的递归导致栈溢出的办法：<br>第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归；<br>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p>
<p>C 语言中 qsort() 的底层实现原理：<br>小规模数据集用归并排序，大规模数据用快速排序，并用堆模拟栈，防止递归函数栈溢出，当元素小于4时，用的是插入排序；因为O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长，时间复杂度是个偏理论的表示方法，计算过程会省略低阶和常数，这些在极小数据集的排序时，也是影响很大的。</p>
<h2 id="第十八天（2020-01-05）："><a href="#第十八天（2020-01-05）：" class="headerlink" title="第十八天（2020-01-05）："></a>第十八天（2020-01-05）：</h2><p>学习了 3 种线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。</p>
<p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。<br>重点的是掌握这些排序算法的适用场景。</p>
<h2 id="第十七天（2020-01-04）："><a href="#第十七天（2020-01-04）：" class="headerlink" title="第十七天（2020-01-04）："></a>第十七天（2020-01-04）：</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p>
<p>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式，然后一步步分解推导。</p>
<p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p>
<h2 id="第十六天（2020-01-03）："><a href="#第十六天（2020-01-03）：" class="headerlink" title="第十六天（2020-01-03）："></a>第十六天（2020-01-03）：</h2><p>分析了三种时间复杂度是 O(n2) 的排序算法，冒泡排序、插入排序、选择排序。讲述如何分析一个“排序算法”。</p>
<p>排序算法的执行效率：</p>
<ol>
<li>最好情况、最坏情况、平均情况时间复杂度；</li>
<li>时间复杂度的系数、常数 、低阶；</li>
<li>比较次数和交换（或移动）次数；</li>
</ol>
<p>排序算法的内存消耗：<br>指空间复杂度大小；<br>原地排序指空间复杂度为O(1)；</p>
<p>排序算法的稳定性：<br>如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>冒泡、插入、选择排序都是原地排序；<br>冒泡、插入是稳定排序；<br>冒泡、插入的最好时间复杂度是O(n)，最坏和平均是O(n2)；选择都是O(n2)；</p>
<p>平时的小数据处理可以用插入排序，实现起来比较清晰。</p>
<h2 id="第十五天（2020-01-02）："><a href="#第十五天（2020-01-02）：" class="headerlink" title="第十五天（2020-01-02）："></a>第十五天（2020-01-02）：</h2><p>《数据结构与算法之美》<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。<br>可以限制递归深度防止堆栈溢出；用缓存结果防止重复计算。</p>
<h2 id="第十四天（2020-01-01）："><a href="#第十四天（2020-01-01）：" class="headerlink" title="第十四天（2020-01-01）："></a>第十四天（2020-01-01）：</h2><p>《数据结构与算法之美》<br>队列只允许入队和出队，也像栈一样是操作受限的数据结构；<br>队列最大的特点就是先进先出。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。<br>队列的应用有阻塞队列和并发队列。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。<br>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p>
<h2 id="第十三天（2019-12-31）："><a href="#第十三天（2019-12-31）：" class="headerlink" title="第十三天（2019-12-31）："></a>第十三天（2019-12-31）：</h2><p>《数据结构与算法之美》<br>栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。<br>栈的功能虽然可以用数组或链表实现，但越灵活的功能可能会造成不可预估的情况，最好能让操作限制在可控可预知的范围内。所以栈虽功能有限，但特殊的结构还是能找到特定的应用场景，比如程序中的栈内存空间。<br>学习怎样利用均摊时间复杂度分析动态扩容顺序栈的时间度。因为它是周期性地出现大时间复杂度的操作，但这又能均摊到周期内小的时间复杂度内，所以最终时间复杂度以小的为准。</p>
<h2 id="第十二天（2019-12-30）："><a href="#第十二天（2019-12-30）：" class="headerlink" title="第十二天（2019-12-30）："></a>第十二天（2019-12-30）：</h2><p>《设计模式之美》<br>为什么要分 MVC 三层开发？<br>代码复用：<br>各层高内聚的封装数据和功能，可被更上层复用；<br>隔离变化：<br>每层都是对特定数据的抽象，某层数据变化不影响其它层；<br>隔离关注点：<br>各层只关注自己关心的数据，相当于代码层面的隔离；<br>提高代码的可测试性：<br>各层输入输出明确，封装性和内聚性高，便于单元测试；<br>应对系统的复杂性：<br>分层方便写出抽象清晰、高内聚、可复用的代码，适合构建复杂系统；</p>
<p>收获：<br>深入理解业务系统的设计初衷，也能提高写代码的能力</p>
<h2 id="第十一天（2019-12-29）："><a href="#第十一天（2019-12-29）：" class="headerlink" title="第十一天（2019-12-29）："></a>第十一天（2019-12-29）：</h2><p>《设计模式之美》<br>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。</p>
<p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p>
<p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。</p>
<p>第十天<br>《设计模式之美》</p>
<ol>
<li>如何理解“高内聚、松耦合”？<br>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。<br>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</li>
<li>如何理解“迪米特法则”？<br>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</li>
</ol>
<h2 id="第九天（2019-12-27）："><a href="#第九天（2019-12-27）：" class="headerlink" title="第九天（2019-12-27）："></a>第九天（2019-12-27）：</h2><p>《设计模式之美》<br>理解DRY原则<br>核心思想：不要做重复的事；</p>
<p>可能遇到的重复的情况：<br>实现逻辑重复<br>这种重复并不一定是违反DRY原则的，需要再看看语义是否重复。如果是两个不同的功能，但实现逻辑有重复的，可以通过复用里层的逻辑来消除代码逻辑上的重复；</p>
<p>功能语义重复<br>这种重复需要被消除；</p>
<p>代码执行重复<br>逻辑在同一功能下被重复执行，需要消除，特别是IO操作；</p>
<p>如何提高代码复用性：<br>减少代码耦合<br>满足单一职责原则<br>模块化<br>通用代码下沉：越通用的代码被依赖的越多，需要下调到更底层，避免下层代码依赖上层逻辑导致依赖关系交叉；<br>继承、多态、封装、抽象；<br>应用模板等设计模式；</p>
<p>收获：<br>避免设计大而全的模块，因为它往往依赖很多，耦合度必然高，可复用性和维护性就会下降；<br>对于模块化、通用代码下沉思想的理解，模块功能足够内聚，可以独立使用，而且依赖是单向的，这样才能像搭积木一样由下向上地做系统；<br>在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性；<br>根据实际应用进行辩证思考和灵活变通，有时候复用的实现成本高，需求又不明确的情况下，可以先实现功能，后续有复用的需求时再调整，但其它原则要尽量遵守，保持代码易懂，方便调整。</p>
<h2 id="第八天（2019-12-26）："><a href="#第八天（2019-12-26）：" class="headerlink" title="第八天（2019-12-26）："></a>第八天（2019-12-26）：</h2><p>《设计模式之美》<br>学习了：<br>理解KISS原则<br>意思就是尽量保持代码简洁</p>
<p>代码行数越少就越“简单”吗？<br>不是。<br>如果代码少但难读懂、难维护，团队的成员很难接手，那便不算简单。<br>如用了大量大段的正则处理字符串，虽然代码行数少，但理解和维护难度增加了很多。</p>
<p>代码复杂就违背KISS原则了吗？<br>本身问题解决的难度大，那代码复杂，并不违背KISS原则。</p>
<p>如何写出满足KISS原则的代码？<br>不要使用团队成员不懂的技术去实现；<br>不要重复造轮子，尽量使用现有成熟的工具；<br>不要过度优化，考虑过多未来的扩展或复杂的条件，只会让问题变得难以实现，或做出来难以理解；<br>检验代码是否简洁：code review，如果同事对代码有很多疑问，那证明这个实现不够简洁；</p>
<p>YANGI跟KISS的区别：<br>YANGI的意思是：你不会需要它，核心思想是：不要过度设计；<br>KISS说的是“如何做”，而YANG说的是“要不要做”。</p>
<p>收获：<br>实际开发中，有时候会想得很远，想让功能变得更灵活，适应所有的变化，但这种方案往往会被否决掉，因为这一般都是过度设计，没必要为了未来可能有的东西而花大力气，就算实现了，往往也会让原本简单的流程变得复杂难懂，增加项目的可维护性，往往都是先实现再优化。<br>KISS原则就是想让我们用一种刚刚好、付出不多不少成本的方式解决问题，现实中需要根据实际场景评估这个边界。</p>
<h2 id="第七天（2019-12-25）："><a href="#第七天（2019-12-25）：" class="headerlink" title="第七天（2019-12-25）："></a>第七天（2019-12-25）：</h2><p>《设计模式之美》<br>学习了：<br>如何理解接口隔离原则？<br>客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。<br>我们可以把“接口”理解为下面三种东西：<br>一组 API 接口集合单个 —— 可以指类或模块；<br>API 接口或函数；<br>OOP中的接口概念；</p>
<p>接口隔离原则与单一职责原则的区别？<br>它们都可以用于类、模块、接口的设计。接口隔离原则还提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<p>收获：<br>原则的使用还是具有一定的主观性，比如判定功能是否单一，在简单的应用场景下很多功能放在一个类是没问题的，用函数就可以分隔出来，但函数多了就需要类，类多了还需要模块，所以无论是接口隔离原则还是单一职责原则，都还需要结合具体的场景。</p>
<h2 id="第六天（2019-12-24）："><a href="#第六天（2019-12-24）：" class="headerlink" title="第六天（2019-12-24）："></a>第六天（2019-12-24）：</h2><p>《设计模式之美》<br>什么是里氏替换原则？<br>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>
<p>哪些代码违背这原则？<br>子类违背父类函数声明要实现的功能；<br>子类违背父类对输入、输出、异常的约定；<br>子类违背父类注释中所罗列的任何特殊说明。</p>
<p>收获<br>多态与里氏替换原则的区别：<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。<br>里氏替换原则要求子类不修改父类，也是遵从开闭原则，要求对修改关闭，影响代码扩展性。</p>
<h2 id="第五天（2019-12-23）："><a href="#第五天（2019-12-23）：" class="headerlink" title="第五天（2019-12-23）："></a>第五天（2019-12-23）：</h2><p>《设计模式之美》<br>理解开闭原则<br>开闭原则指模块、类的设计需要对扩展开放，对修改关闭。</p>
<p>原则内容比较简明，但实际要做到这一点需要综合实际的逻辑考虑，而不是看有没有修改类的属性或方法这种硬套的规则。<br>原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。<br>我觉得扩展是指保持原有的核心可复用逻辑保持不变，原有的测试基本不变，修改则相反，会破坏核心的、可复用的逻辑，导致各个关联的模块都需要同时跟着调整。</p>
<p>如何实行这一原则？<br>这需要我们在开发中时刻保持扩展意识、抽象意识、封装意识，这些意识比任务开发技巧都重要。</p>
<h2 id="第四天（2019-12-22）："><a href="#第四天（2019-12-22）：" class="headerlink" title="第四天（2019-12-22）："></a>第四天（2019-12-22）：</h2><p>《设计模式之美》<br>理解单一职责原则<br>它是面向对象设计的原则之一，指导类和模块甚至方法函数的设计。</p>
<p>如何判断职责是否单一？<br>从业务场景出发，某一类逻辑复杂了，就需要抽离出来作为单独的模块。<br>复杂可表现为：属性或方法过多，依赖的类过多，集中操作某几个属性，很难给类命名，总之只要感觉维护起来麻烦了，改个细节要考虑很多可能的影响的时候，就证明设计有问题了。原则就的初衷是为了提高代码可读性和易维护性。</p>
<p>功能是否越单一越好？<br>不是。功能考虑内聚性，试想一个共同使用的数据或依赖的逻辑写好几份在不同的模块上，改起来多痛苦！所以功能内聚了，维护和可读性就上去了。</p>
<h2 id="第三天（2019-12-21）："><a href="#第三天（2019-12-21）：" class="headerlink" title="第三天（2019-12-21）："></a>第三天（2019-12-21）：</h2><p>《设计模式之美》<br>从一个鉴权功能的构建中学习到面向对象开发的方法：<br>首先是需求分析：<br>我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。<br>需求分析的过程实际上是一个不断迭代优化的过程，可以先尝试做基础的版本，再逐渐深入分析和优化，迭代版本。</p>
<p>明确需求后，就是设计和实现的流程：<br>1、划分职责进而识别出有哪些类：<br> 这一步应该是最难的，因为类抽象得过细会导致功能不够内聚，抽象的范围大了又会导致数据耦合，这应该就要根据经验来判断了吧。作者提了他的方法是将功能点列出来，找职责相似的功能点合并抽象为一类，还有一些书籍提供的方法是将功能点里的名词抽象为类；我觉得这些都可以作为前期的抽象方法，开发过程或维护过程可以再迭代调整；</p>
<p>2、定义类及其属性和方法：<br> 我觉得属性就是功能点里的名词，方法就是动词，主要就是要注意方法的单一权责问题；</p>
<p>3、定义类与类之间的交互关系：<br> 分为以下四种：<br>泛化：类间的继承关系；<br>实现：接口与类的关系；<br>组合：类实例是另一个类的成员；<br>依赖：类实例在另一个类中被使用；<br>通过这些关系，将各个类拉在一起，构成功能；</p>
<p>4、将类组装起来并提供执行入口：<br> 构建一个入口（类或方法），组装各个类，暴露明确的接口给使用者。</p>
<p>一点启发：<br>如果在看这些教程之前，我设计鉴权功能，肯定是将它们包含在一个类里，然后定义各种变量、方法，子方法实现具体功能点，再用公共的方法将各个子方法组装起来。这种设计是我平时做的最多的，因为需求实现得快，但如果放任不管，随时业务迭代，变量和方法越来越多，功能维护起来就十分得困难。如果用面向对象的话来说，就是没有抽象、封装、数据耦合，这是平时用面向过程的思路去开发所带来的弊端。看了作者的实现思路，给了我另外去设计架构的思路：需求分析、抽象、封装、定义交互关系。这也解惑了我这么久以来觉得为什么看到有些框架要定义那么多类的原因，其实类就是用来抽象、封装，让数据间的关系解耦的同时又保持功能的内聚。代码被读的次数远多于被写的次数，保持易维护、易读是软件开发中必须要掌握的技能。<br>个人觉得：一开始可能会不习惯，但时刻保持这种意识，遇到不爽的地方多想想多改改，会是个不错的方法，因为开发本身就是个实践动手的事，理论再多没用上也是废的，不断实践锻炼意识和积累经验才能适应变化。</p>
<h2 id="第二天（2019-12-20）："><a href="#第二天（2019-12-20）：" class="headerlink" title="第二天（2019-12-20）："></a>第二天（2019-12-20）：</h2><p>《设计模式之美》<br>了解贫血模型与充血模型：<br>1、贫血模型将数据与操作分离，违背了面向对象的封装要求，是一种典型的面向过程编程风格；<br>2、充血模型则是将数据与操作封装到同一个类，满足面向对象的封装要求，是典型的面向对象网络；<br>3、设计复杂业务时，充血模型比较适合，复杂业务往往涉及很多代码需要复用，充血模型更适合抽象需要复用的逻辑；<br>4、如果业务简单，贫血模型能够较快速地开发实现功能；<br>5、典型的MVC三层架构就是用贫血模型，可以通过改造业务逻辑（service）层，将其中的高业务复杂度的逻辑抽离为充血模式，保持可复用性和易维护性，再由service层依赖并暴露给controller层，service层同时保留业务简单的功能，且负责业务聚合，聚合model数据与controler数据到充血模式的领域模型中。</p>
<h2 id="第一天（2019-12-19）："><a href="#第一天（2019-12-19）：" class="headerlink" title="第一天（2019-12-19）："></a>第一天（2019-12-19）：</h2><p>《设计模式之美》<br>为什么要多用组合少用继承？<br>继承和组合都能解决抽象和代码复用问题，但实际开发场景的实体往往共性少特性多，继承的方式往往需要抽象多个类并且出现多层次的关系，导致逻辑耦合过深，影响可读性。组合的方式反而更灵活和轻量。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/99.html">yum install找不到软件怎么办？</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/linux/">linux</a></span><div class="content"><h1 id="yum找不到软件？"><a href="#yum找不到软件？" class="headerlink" title="yum找不到软件？"></a>yum找不到软件？</h1><p>可以尝试安装新的源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  install epel-release</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=extras install epel-release</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/98.html">浅析npm与yarn全局包的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/node-js/">node.js</a></span><div class="content"><h1 id="浅析npm与yarn全局包的区别"><a href="#浅析npm与yarn全局包的区别" class="headerlink" title="浅析npm与yarn全局包的区别"></a>浅析npm与yarn全局包的区别</h1><h2 id="yarn与npm怎样装全局包"><a href="#yarn与npm怎样装全局包" class="headerlink" title="yarn与npm怎样装全局包"></a>yarn与npm怎样装全局包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn global add package;</span><br><span class="line">npm i package --g;</span><br></pre></td></tr></table></figure>
<p>注：npm在普通用户下要用sudo</p>
<h2 id="问题：为什么yarn和npm装全局包产生的效果是一样的吗？"><a href="#问题：为什么yarn和npm装全局包产生的效果是一样的吗？" class="headerlink" title="问题：为什么yarn和npm装全局包产生的效果是一样的吗？"></a>问题：为什么yarn和npm装全局包产生的效果是一样的吗？</h2><p>我们都知道yarn是npm的cli，但一直以为yarn安装的时候跟npm产生的效果一样，这个一样是指安装了本地包就本地使用，全局包就可以像npm安装后用命令行使用，但实际结果却是不一样的。<br>其实从命令执行的权限来看就不一样了，平时用的时候，yarn不用sudo，npm需要用sudo，这其中产生的结果肯定不一样。</p>
<p>下面用几个例子说明一下：<br>例如用npm装pm2的包，并用yarn和npm查看全局包；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i pm2 -g</span><br><span class="line">npm l -g --depth=0</span><br><span class="line">yarn global list</span><br></pre></td></tr></table></figure>
<p>npm会显示用pm2这个包，yarn却不会；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global add webpack</span><br><span class="line">npm l -g --depth=0</span><br><span class="line">yarn global list</span><br></pre></td></tr></table></figure>
<p>同样用yarn安装了全局包，在npm的全局包上查看不到。</p>
<h2 id="找到了答案"><a href="#找到了答案" class="headerlink" title="找到了答案"></a>找到了答案</h2><p>来自yarn global的文档：</p>
<blockquote>
<p>注：不像 npm 里的 –global 标志，global 是一个必须跟在 yarn 后面的命令。 输入 yarn add global package-name 会把名为 global 和 package-name 的包添加到本地，而非全局添加 package-name。</p>
</blockquote>
<p>意思是yarn global只是把package安装在本地，但项目却可以像全局包一样使用，这样也可以减少项目的更新对全局依赖的影响。但也可以通过prefix装包装到系统全局，就跟npm一样了。不愧是几个大厂搞出来的管理工具，考虑得很全面。</p>
<h2 id="另外填上最近踩的一个坑"><a href="#另外填上最近踩的一个坑" class="headerlink" title="另外填上最近踩的一个坑"></a>另外填上最近踩的一个坑</h2><p>我们用pm2 deloy作部署发布脚本，大概如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;apps&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;HTTP-API&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;script&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;http.js&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;deploy&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;production&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;user&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.0.13&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;ref&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;origin/master&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;repo&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;git@github.com:Username/repository.git&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;path&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;/var/www/my-repository&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;post-deploy&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;yarn install; pm2 start pm2.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">	   <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	   		<span class="attr">&quot;NODE_ENV&quot;</span><span class="punctuation">:</span> <span class="string">&quot;production&quot;</span></span><br><span class="line">	   <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>首先项目里有devDependencies，打包需要安装这些包。然后部署的时候就出现问题了，一直提示devDependencies里的某个包不存在，但手动跑deploy里的命令却是正常的。后来才发现env里指定了NODE_ENV为production，导致yarn不安装devDependencies里的包。<br>再次引用文档说明：</p>
<blockquote>
<p>yarn install –production[&#x3D;true|false]<br>如果 NODE_ENV 环境变量设为 production，Yarn 将不安装任何列于 devDependencies 的包。 使用此标志指示 Yarn 忽略 NODE_ENV 并用它取代“生产”与否的状态。</p>
</blockquote>
<p>所以解决方法就是将post-deploy改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install --production=false; pm2 start pm2.json</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://yarnpkg.com/zh-Hans/docs/cli/install#search">yarn install</a><br><a target="_blank" rel="noopener" href="https://yarnpkg.com/zh-Hans/docs/cli/global">yarn global</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By 杨润炜</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>