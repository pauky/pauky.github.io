<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="杨润炜"><meta name="copyright" content="杨润炜"><title>Cwalker</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.1.0'
} </script><meta name="generator" content="Hexo 6.1.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">杨润炜</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">131</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cwalker</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Cwalker</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/a/101.html">《斗破苍穹》读后感</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/life/">life</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/read/">read</a></span><div class="content"><p>看完这部小说的事已经过去了两个月，今天突然想起要给自己第一次完整看完的长篇小说《斗破苍穹》写个读后感。看书的时候，故事总能激起内心热血的一面，同时我也很敬佩他，因为他总能不断突破自己。可能是最近对于自我提升的迫切感和焦虑感，让我又想起了小说里特别拼的主角萧炎。他是怎样一步步走向成长并最终到达巅峰的呢？</p>
<p>我觉得主角能成神，除了因为有主角光环之外，还有以下几点原因：</p>
<h4 id="一波接一波的推动力，逼他不断地提升自己；"><a href="#一波接一波的推动力，逼他不断地提升自己；" class="headerlink" title="一波接一波的推动力，逼他不断地提升自己；"></a>一波接一波的推动力，逼他不断地提升自己；</h4><p>小时候因为“失去”天赋，周围人的嘲笑成为他不断修炼的动力；<br>婚约被毁，失去了最后尊严的他，只能破釜沉舟立下三年之约，他便靠着这股劲走遍了大半个帝国，每天只记得修炼，只想拿回尊严，他几乎是凭着这动物本性，一人对抗当时帝国最大势力——云岚宗；<br>本来打赢了三年之约，打算平淡地过一生，小说也可以完毕。没想到老爹、恩师被魂殿抓走了，他不得不对抗这股在大陆上人人畏惧的势力，修炼又不能停下了，而且还要比以前更努力，因为对手太强太强了；<br>后来，迦南学院的同龄学生竞争，到大陆中心强者的接连追杀，为了保护自己、保护自己在乎的人，只能是不断折腾，一刻也不能停。<br>在整部小说里，主角几乎就是处于这种被动状态，接连不断的推动力、压力落在身上，逼着他向前走。</p>
<h4 id="分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；"><a href="#分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；" class="headerlink" title="分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；"></a>分解目标，并踏踏实实一步一脚印地成长，不依赖所谓的一步到位的提升；</h4><p>在小说里，有很多人是通过吃药或各种捷径来取得提升的，主角也有很多机会可以得到，几乎唾手可得，但他却放弃了，明明他的焦虑感是最重的，却能踏踏实实一阶阶地修炼提升。总感觉这是个bug，现实中大家都想“偷懒”，少走点路少做点事，按部就班都被当成奇葩了。偏偏主角就是个奇葩。</p>
<h4 id="目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；"><a href="#目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；" class="headerlink" title="目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；"></a>目标坚定，遇到各种诱惑，都能始终如一地坚持初衷；</h4><p>小说里的美女，没有哪一个不跟主角眉来眼去的。英雄难过美人关，主角居然不买帐，这也是个bug吧。不过主角确实不觉得自己是救世主或英雄，他只是在做一件平常的事，保护自己、保护在乎的人。这种一根筋的人，确实没办法被色诱的吧。就算是给他一打绝色美女，又或者是整个帝国，都始终没能动摇他对目标的坚持。</p>
<h4 id="不逞英雄，相信团队；"><a href="#不逞英雄，相信团队；" class="headerlink" title="不逞英雄，相信团队；"></a>不逞英雄，相信团队；</h4><p>主角在迦南学院学到的最重要的技能，就是“拉帮结派”。他开始意识到一个人能力有限，得借助并相信队友，组建团队才能走得更远。随着建立磐门到萧门到炎盟到天府盟，他随着团队的壮大，自身的提升速度和能提升到的最大点也不断增大。</p>
<h4 id="最后，最重要的一点：局势造就英雄；"><a href="#最后，最重要的一点：局势造就英雄；" class="headerlink" title="最后，最重要的一点：局势造就英雄；"></a>最后，最重要的一点：局势造就英雄；</h4><p>如果没有魂殿的阴谋，没有他企图毁灭整个中洲的大背景，主角应该到死还在家当掌柜卖药材吧。</p>
<p>以上就是我认为主角为什么能走向巅峰的原因。这些原因也是我最近对于如何学习的一些看法。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/100.html">极客时间官方21天打卡行动第一期</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/geekbang/">geekbang</a></span><div class="content"><h1 id="极客时间上的21天打卡"><a href="#极客时间上的21天打卡" class="headerlink" title="极客时间上的21天打卡"></a>极客时间上的21天打卡</h1><p>立个flag，完成极客时间的21天打卡行动（完结）。</p>
<p>从 2019-12-19 到 2020-01-08 连续21天不间断打卡，即使中间有时候遇到很忙碌的情况，还是会想着学习一会打个卡，而且慢慢会养成固定时间学习的习惯。虽然21天学习下来知识没怎么涨，但习惯的养成估计更有价值。希望这次“跨年之战”的热情和精神能继续发扬，最终形成自己的学习习惯。</p>
<h2 id="第二十一天（2020-01-08）："><a href="#第二十一天（2020-01-08）：" class="headerlink" title="第二十一天（2020-01-08）："></a>第二十一天（2020-01-08）：</h2><p>《数据结构与算法之美》</p>
<p>学习了跳表这种数据结构。跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)；</p>
<p>如果链表节点有变动，需要动态更新多级索引来维持跳表的“平衡性”，一般是通过随机函数实现的，从概率上能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化；</p>
<p>redis的有序集合就是用跳表实现的；</p>
<p>跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p>
<h2 id="第二十天（2020-01-07）："><a href="#第二十天（2020-01-07）：" class="headerlink" title="第二十天（2020-01-07）："></a>第二十天（2020-01-07）：</h2><p>《数据结构与算法之美》</p>
<p>二分查找是一种非常高效的查找算法，O(logn)对数时间复杂度，比如在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次，极其高效；</p>
<p>二分查找应用场景的局限性：<br>二分查找依赖的是顺序表结构，简单点说就是数组；<br>二分查找针对的是有序数据；<br>数据量太小或太大不适合二分查找，太小不必要用这么复杂的算法，太大又会占用太多连续内存空间；<br>二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作；</p>
<p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p>
<h2 id="第十九天（2020-01-06）："><a href="#第十九天（2020-01-06）：" class="headerlink" title="第十九天（2020-01-06）："></a>第十九天（2020-01-06）：</h2><p>《数据结构与算法之美》<br>哪种排序算法适合用来做通用的排序函数？<br>线性排序的适用场景比较严格，不够通用；<br>复杂度为O(n2)适用小规模数据集，不够通用；<br>剩下时间复杂度是 O(nlogn)的归并和快速排序，但归并不是原地排序，数据多了会占用更多的内存，所以快速排序比较适合来实现排序函数；</p>
<p>如何优化快速排序？<br>因为快速排序的最坏情况时间复杂度是O(n2)，需要想办法优化。<br>O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理；<br>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p>
<p>两个比较常用、比较简单的分区算法：<br>三数取中法；<br>随机法；</p>
<p>防止快速排序的递归导致栈溢出的办法：<br>第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归；<br>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p>
<p>C 语言中 qsort() 的底层实现原理：<br>小规模数据集用归并排序，大规模数据用快速排序，并用堆模拟栈，防止递归函数栈溢出，当元素小于4时，用的是插入排序；因为O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长，时间复杂度是个偏理论的表示方法，计算过程会省略低阶和常数，这些在极小数据集的排序时，也是影响很大的。</p>
<h2 id="第十八天（2020-01-05）："><a href="#第十八天（2020-01-05）：" class="headerlink" title="第十八天（2020-01-05）："></a>第十八天（2020-01-05）：</h2><p>学习了 3 种线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。</p>
<p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。<br>重点的是掌握这些排序算法的适用场景。</p>
<h2 id="第十七天（2020-01-04）："><a href="#第十七天（2020-01-04）：" class="headerlink" title="第十七天（2020-01-04）："></a>第十七天（2020-01-04）：</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p>
<p>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式，然后一步步分解推导。</p>
<p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p>
<h2 id="第十六天（2020-01-03）："><a href="#第十六天（2020-01-03）：" class="headerlink" title="第十六天（2020-01-03）："></a>第十六天（2020-01-03）：</h2><p>分析了三种时间复杂度是 O(n2) 的排序算法，冒泡排序、插入排序、选择排序。讲述如何分析一个“排序算法”。</p>
<p>排序算法的执行效率：</p>
<ol>
<li>最好情况、最坏情况、平均情况时间复杂度；</li>
<li>时间复杂度的系数、常数 、低阶；</li>
<li>比较次数和交换（或移动）次数；</li>
</ol>
<p>排序算法的内存消耗：<br>指空间复杂度大小；<br>原地排序指空间复杂度为O(1)；</p>
<p>排序算法的稳定性：<br>如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>冒泡、插入、选择排序都是原地排序；<br>冒泡、插入是稳定排序；<br>冒泡、插入的最好时间复杂度是O(n)，最坏和平均是O(n2)；选择都是O(n2)；</p>
<p>平时的小数据处理可以用插入排序，实现起来比较清晰。</p>
<h2 id="第十五天（2020-01-02）："><a href="#第十五天（2020-01-02）：" class="headerlink" title="第十五天（2020-01-02）："></a>第十五天（2020-01-02）：</h2><p>《数据结构与算法之美》<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。<br>可以限制递归深度防止堆栈溢出；用缓存结果防止重复计算。</p>
<h2 id="第十四天（2020-01-01）："><a href="#第十四天（2020-01-01）：" class="headerlink" title="第十四天（2020-01-01）："></a>第十四天（2020-01-01）：</h2><p>《数据结构与算法之美》<br>队列只允许入队和出队，也像栈一样是操作受限的数据结构；<br>队列最大的特点就是先进先出。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。<br>队列的应用有阻塞队列和并发队列。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。<br>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p>
<h2 id="第十三天（2019-12-31）："><a href="#第十三天（2019-12-31）：" class="headerlink" title="第十三天（2019-12-31）："></a>第十三天（2019-12-31）：</h2><p>《数据结构与算法之美》<br>栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。<br>栈的功能虽然可以用数组或链表实现，但越灵活的功能可能会造成不可预估的情况，最好能让操作限制在可控可预知的范围内。所以栈虽功能有限，但特殊的结构还是能找到特定的应用场景，比如程序中的栈内存空间。<br>学习怎样利用均摊时间复杂度分析动态扩容顺序栈的时间度。因为它是周期性地出现大时间复杂度的操作，但这又能均摊到周期内小的时间复杂度内，所以最终时间复杂度以小的为准。</p>
<h2 id="第十二天（2019-12-30）："><a href="#第十二天（2019-12-30）：" class="headerlink" title="第十二天（2019-12-30）："></a>第十二天（2019-12-30）：</h2><p>《设计模式之美》<br>为什么要分 MVC 三层开发？<br>代码复用：<br>各层高内聚的封装数据和功能，可被更上层复用；<br>隔离变化：<br>每层都是对特定数据的抽象，某层数据变化不影响其它层；<br>隔离关注点：<br>各层只关注自己关心的数据，相当于代码层面的隔离；<br>提高代码的可测试性：<br>各层输入输出明确，封装性和内聚性高，便于单元测试；<br>应对系统的复杂性：<br>分层方便写出抽象清晰、高内聚、可复用的代码，适合构建复杂系统；</p>
<p>收获：<br>深入理解业务系统的设计初衷，也能提高写代码的能力</p>
<h2 id="第十一天（2019-12-29）："><a href="#第十一天（2019-12-29）：" class="headerlink" title="第十一天（2019-12-29）："></a>第十一天（2019-12-29）：</h2><p>《设计模式之美》<br>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。</p>
<p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p>
<p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。</p>
<p>第十天<br>《设计模式之美》</p>
<ol>
<li>如何理解“高内聚、松耦合”？<br>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。<br>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</li>
<li>如何理解“迪米特法则”？<br>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</li>
</ol>
<h2 id="第九天（2019-12-27）："><a href="#第九天（2019-12-27）：" class="headerlink" title="第九天（2019-12-27）："></a>第九天（2019-12-27）：</h2><p>《设计模式之美》<br>理解DRY原则<br>核心思想：不要做重复的事；</p>
<p>可能遇到的重复的情况：<br>实现逻辑重复<br>这种重复并不一定是违反DRY原则的，需要再看看语义是否重复。如果是两个不同的功能，但实现逻辑有重复的，可以通过复用里层的逻辑来消除代码逻辑上的重复；</p>
<p>功能语义重复<br>这种重复需要被消除；</p>
<p>代码执行重复<br>逻辑在同一功能下被重复执行，需要消除，特别是IO操作；</p>
<p>如何提高代码复用性：<br>减少代码耦合<br>满足单一职责原则<br>模块化<br>通用代码下沉：越通用的代码被依赖的越多，需要下调到更底层，避免下层代码依赖上层逻辑导致依赖关系交叉；<br>继承、多态、封装、抽象；<br>应用模板等设计模式；</p>
<p>收获：<br>避免设计大而全的模块，因为它往往依赖很多，耦合度必然高，可复用性和维护性就会下降；<br>对于模块化、通用代码下沉思想的理解，模块功能足够内聚，可以独立使用，而且依赖是单向的，这样才能像搭积木一样由下向上地做系统；<br>在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性；<br>根据实际应用进行辩证思考和灵活变通，有时候复用的实现成本高，需求又不明确的情况下，可以先实现功能，后续有复用的需求时再调整，但其它原则要尽量遵守，保持代码易懂，方便调整。</p>
<h2 id="第八天（2019-12-26）："><a href="#第八天（2019-12-26）：" class="headerlink" title="第八天（2019-12-26）："></a>第八天（2019-12-26）：</h2><p>《设计模式之美》<br>学习了：<br>理解KISS原则<br>意思就是尽量保持代码简洁</p>
<p>代码行数越少就越“简单”吗？<br>不是。<br>如果代码少但难读懂、难维护，团队的成员很难接手，那便不算简单。<br>如用了大量大段的正则处理字符串，虽然代码行数少，但理解和维护难度增加了很多。</p>
<p>代码复杂就违背KISS原则了吗？<br>本身问题解决的难度大，那代码复杂，并不违背KISS原则。</p>
<p>如何写出满足KISS原则的代码？<br>不要使用团队成员不懂的技术去实现；<br>不要重复造轮子，尽量使用现有成熟的工具；<br>不要过度优化，考虑过多未来的扩展或复杂的条件，只会让问题变得难以实现，或做出来难以理解；<br>检验代码是否简洁：code review，如果同事对代码有很多疑问，那证明这个实现不够简洁；</p>
<p>YANGI跟KISS的区别：<br>YANGI的意思是：你不会需要它，核心思想是：不要过度设计；<br>KISS说的是“如何做”，而YANG说的是“要不要做”。</p>
<p>收获：<br>实际开发中，有时候会想得很远，想让功能变得更灵活，适应所有的变化，但这种方案往往会被否决掉，因为这一般都是过度设计，没必要为了未来可能有的东西而花大力气，就算实现了，往往也会让原本简单的流程变得复杂难懂，增加项目的可维护性，往往都是先实现再优化。<br>KISS原则就是想让我们用一种刚刚好、付出不多不少成本的方式解决问题，现实中需要根据实际场景评估这个边界。</p>
<h2 id="第七天（2019-12-25）："><a href="#第七天（2019-12-25）：" class="headerlink" title="第七天（2019-12-25）："></a>第七天（2019-12-25）：</h2><p>《设计模式之美》<br>学习了：<br>如何理解接口隔离原则？<br>客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。<br>我们可以把“接口”理解为下面三种东西：<br>一组 API 接口集合单个 —— 可以指类或模块；<br>API 接口或函数；<br>OOP中的接口概念；</p>
<p>接口隔离原则与单一职责原则的区别？<br>它们都可以用于类、模块、接口的设计。接口隔离原则还提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<p>收获：<br>原则的使用还是具有一定的主观性，比如判定功能是否单一，在简单的应用场景下很多功能放在一个类是没问题的，用函数就可以分隔出来，但函数多了就需要类，类多了还需要模块，所以无论是接口隔离原则还是单一职责原则，都还需要结合具体的场景。</p>
<h2 id="第六天（2019-12-24）："><a href="#第六天（2019-12-24）：" class="headerlink" title="第六天（2019-12-24）："></a>第六天（2019-12-24）：</h2><p>《设计模式之美》<br>什么是里氏替换原则？<br>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>
<p>哪些代码违背这原则？<br>子类违背父类函数声明要实现的功能；<br>子类违背父类对输入、输出、异常的约定；<br>子类违背父类注释中所罗列的任何特殊说明。</p>
<p>收获<br>多态与里氏替换原则的区别：<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。<br>里氏替换原则要求子类不修改父类，也是遵从开闭原则，要求对修改关闭，影响代码扩展性。</p>
<h2 id="第五天（2019-12-23）："><a href="#第五天（2019-12-23）：" class="headerlink" title="第五天（2019-12-23）："></a>第五天（2019-12-23）：</h2><p>《设计模式之美》<br>理解开闭原则<br>开闭原则指模块、类的设计需要对扩展开放，对修改关闭。</p>
<p>原则内容比较简明，但实际要做到这一点需要综合实际的逻辑考虑，而不是看有没有修改类的属性或方法这种硬套的规则。<br>原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。<br>我觉得扩展是指保持原有的核心可复用逻辑保持不变，原有的测试基本不变，修改则相反，会破坏核心的、可复用的逻辑，导致各个关联的模块都需要同时跟着调整。</p>
<p>如何实行这一原则？<br>这需要我们在开发中时刻保持扩展意识、抽象意识、封装意识，这些意识比任务开发技巧都重要。</p>
<h2 id="第四天（2019-12-22）："><a href="#第四天（2019-12-22）：" class="headerlink" title="第四天（2019-12-22）："></a>第四天（2019-12-22）：</h2><p>《设计模式之美》<br>理解单一职责原则<br>它是面向对象设计的原则之一，指导类和模块甚至方法函数的设计。</p>
<p>如何判断职责是否单一？<br>从业务场景出发，某一类逻辑复杂了，就需要抽离出来作为单独的模块。<br>复杂可表现为：属性或方法过多，依赖的类过多，集中操作某几个属性，很难给类命名，总之只要感觉维护起来麻烦了，改个细节要考虑很多可能的影响的时候，就证明设计有问题了。原则就的初衷是为了提高代码可读性和易维护性。</p>
<p>功能是否越单一越好？<br>不是。功能考虑内聚性，试想一个共同使用的数据或依赖的逻辑写好几份在不同的模块上，改起来多痛苦！所以功能内聚了，维护和可读性就上去了。</p>
<h2 id="第三天（2019-12-21）："><a href="#第三天（2019-12-21）：" class="headerlink" title="第三天（2019-12-21）："></a>第三天（2019-12-21）：</h2><p>《设计模式之美》<br>从一个鉴权功能的构建中学习到面向对象开发的方法：<br>首先是需求分析：<br>我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。<br>需求分析的过程实际上是一个不断迭代优化的过程，可以先尝试做基础的版本，再逐渐深入分析和优化，迭代版本。</p>
<p>明确需求后，就是设计和实现的流程：<br>1、划分职责进而识别出有哪些类：<br> 这一步应该是最难的，因为类抽象得过细会导致功能不够内聚，抽象的范围大了又会导致数据耦合，这应该就要根据经验来判断了吧。作者提了他的方法是将功能点列出来，找职责相似的功能点合并抽象为一类，还有一些书籍提供的方法是将功能点里的名词抽象为类；我觉得这些都可以作为前期的抽象方法，开发过程或维护过程可以再迭代调整；</p>
<p>2、定义类及其属性和方法：<br> 我觉得属性就是功能点里的名词，方法就是动词，主要就是要注意方法的单一权责问题；</p>
<p>3、定义类与类之间的交互关系：<br> 分为以下四种：<br>泛化：类间的继承关系；<br>实现：接口与类的关系；<br>组合：类实例是另一个类的成员；<br>依赖：类实例在另一个类中被使用；<br>通过这些关系，将各个类拉在一起，构成功能；</p>
<p>4、将类组装起来并提供执行入口：<br> 构建一个入口（类或方法），组装各个类，暴露明确的接口给使用者。</p>
<p>一点启发：<br>如果在看这些教程之前，我设计鉴权功能，肯定是将它们包含在一个类里，然后定义各种变量、方法，子方法实现具体功能点，再用公共的方法将各个子方法组装起来。这种设计是我平时做的最多的，因为需求实现得快，但如果放任不管，随时业务迭代，变量和方法越来越多，功能维护起来就十分得困难。如果用面向对象的话来说，就是没有抽象、封装、数据耦合，这是平时用面向过程的思路去开发所带来的弊端。看了作者的实现思路，给了我另外去设计架构的思路：需求分析、抽象、封装、定义交互关系。这也解惑了我这么久以来觉得为什么看到有些框架要定义那么多类的原因，其实类就是用来抽象、封装，让数据间的关系解耦的同时又保持功能的内聚。代码被读的次数远多于被写的次数，保持易维护、易读是软件开发中必须要掌握的技能。<br>个人觉得：一开始可能会不习惯，但时刻保持这种意识，遇到不爽的地方多想想多改改，会是个不错的方法，因为开发本身就是个实践动手的事，理论再多没用上也是废的，不断实践锻炼意识和积累经验才能适应变化。</p>
<h2 id="第二天（2019-12-20）："><a href="#第二天（2019-12-20）：" class="headerlink" title="第二天（2019-12-20）："></a>第二天（2019-12-20）：</h2><p>《设计模式之美》<br>了解贫血模型与充血模型：<br>1、贫血模型将数据与操作分离，违背了面向对象的封装要求，是一种典型的面向过程编程风格；<br>2、充血模型则是将数据与操作封装到同一个类，满足面向对象的封装要求，是典型的面向对象网络；<br>3、设计复杂业务时，充血模型比较适合，复杂业务往往涉及很多代码需要复用，充血模型更适合抽象需要复用的逻辑；<br>4、如果业务简单，贫血模型能够较快速地开发实现功能；<br>5、典型的MVC三层架构就是用贫血模型，可以通过改造业务逻辑（service）层，将其中的高业务复杂度的逻辑抽离为充血模式，保持可复用性和易维护性，再由service层依赖并暴露给controller层，service层同时保留业务简单的功能，且负责业务聚合，聚合model数据与controler数据到充血模式的领域模型中。</p>
<h2 id="第一天（2019-12-19）："><a href="#第一天（2019-12-19）：" class="headerlink" title="第一天（2019-12-19）："></a>第一天（2019-12-19）：</h2><p>《设计模式之美》<br>为什么要多用组合少用继承？<br>继承和组合都能解决抽象和代码复用问题，但实际开发场景的实体往往共性少特性多，继承的方式往往需要抽象多个类并且出现多层次的关系，导致逻辑耦合过深，影响可读性。组合的方式反而更灵活和轻量。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/99.html">yum install找不到软件怎么办？</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/linux/">linux</a></span><div class="content"><h1 id="yum找不到软件？"><a href="#yum找不到软件？" class="headerlink" title="yum找不到软件？"></a>yum找不到软件？</h1><p>可以尝试安装新的源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  install epel-release</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=extras install epel-release</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/98.html">浅析npm与yarn全局包的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/node-js/">node.js</a></span><div class="content"><h1 id="浅析npm与yarn全局包的区别"><a href="#浅析npm与yarn全局包的区别" class="headerlink" title="浅析npm与yarn全局包的区别"></a>浅析npm与yarn全局包的区别</h1><h2 id="yarn与npm怎样装全局包"><a href="#yarn与npm怎样装全局包" class="headerlink" title="yarn与npm怎样装全局包"></a>yarn与npm怎样装全局包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn global add package;</span><br><span class="line">npm i package --g;</span><br></pre></td></tr></table></figure>
<p>注：npm在普通用户下要用sudo</p>
<h2 id="问题：为什么yarn和npm装全局包产生的效果是一样的吗？"><a href="#问题：为什么yarn和npm装全局包产生的效果是一样的吗？" class="headerlink" title="问题：为什么yarn和npm装全局包产生的效果是一样的吗？"></a>问题：为什么yarn和npm装全局包产生的效果是一样的吗？</h2><p>我们都知道yarn是npm的cli，但一直以为yarn安装的时候跟npm产生的效果一样，这个一样是指安装了本地包就本地使用，全局包就可以像npm安装后用命令行使用，但实际结果却是不一样的。<br>其实从命令执行的权限来看就不一样了，平时用的时候，yarn不用sudo，npm需要用sudo，这其中产生的结果肯定不一样。</p>
<p>下面用几个例子说明一下：<br>例如用npm装pm2的包，并用yarn和npm查看全局包；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i pm2 -g</span><br><span class="line">npm l -g --depth=0</span><br><span class="line">yarn global list</span><br></pre></td></tr></table></figure>
<p>npm会显示用pm2这个包，yarn却不会；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global add webpack</span><br><span class="line">npm l -g --depth=0</span><br><span class="line">yarn global list</span><br></pre></td></tr></table></figure>
<p>同样用yarn安装了全局包，在npm的全局包上查看不到。</p>
<h2 id="找到了答案"><a href="#找到了答案" class="headerlink" title="找到了答案"></a>找到了答案</h2><p>来自yarn global的文档：</p>
<blockquote>
<p>注：不像 npm 里的 –global 标志，global 是一个必须跟在 yarn 后面的命令。 输入 yarn add global package-name 会把名为 global 和 package-name 的包添加到本地，而非全局添加 package-name。</p>
</blockquote>
<p>意思是yarn global只是把package安装在本地，但项目却可以像全局包一样使用，这样也可以减少项目的更新对全局依赖的影响。但也可以通过prefix装包装到系统全局，就跟npm一样了。不愧是几个大厂搞出来的管理工具，考虑得很全面。</p>
<h2 id="另外填上最近踩的一个坑"><a href="#另外填上最近踩的一个坑" class="headerlink" title="另外填上最近踩的一个坑"></a>另外填上最近踩的一个坑</h2><p>我们用pm2 deloy作部署发布脚本，大概如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;apps&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;HTTP-API&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;script&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;http.js&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;deploy&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;production&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;user&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;host&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.0.13&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;ref&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;origin/master&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;repo&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;git@github.com:Username/repository.git&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;path&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;/var/www/my-repository&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;post-deploy&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;yarn install; pm2 start pm2.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">	   <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	   		<span class="attr">&quot;NODE_ENV&quot;</span><span class="punctuation">:</span> <span class="string">&quot;production&quot;</span></span><br><span class="line">	   <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>首先项目里有devDependencies，打包需要安装这些包。然后部署的时候就出现问题了，一直提示devDependencies里的某个包不存在，但手动跑deploy里的命令却是正常的。后来才发现env里指定了NODE_ENV为production，导致yarn不安装devDependencies里的包。<br>再次引用文档说明：</p>
<blockquote>
<p>yarn install –production[&#x3D;true|false]<br>如果 NODE_ENV 环境变量设为 production，Yarn 将不安装任何列于 devDependencies 的包。 使用此标志指示 Yarn 忽略 NODE_ENV 并用它取代“生产”与否的状态。</p>
</blockquote>
<p>所以解决方法就是将post-deploy改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install --production=false; pm2 start pm2.json</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://yarnpkg.com/zh-Hans/docs/cli/install#search">yarn install</a><br><a target="_blank" rel="noopener" href="https://yarnpkg.com/zh-Hans/docs/cli/global">yarn global</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/97.html">了解支持向量机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="了解支持向量机"><a href="#了解支持向量机" class="headerlink" title="了解支持向量机"></a>了解支持向量机</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.什么是支持向量机</li>
<li>2.如何寻找最大间隔</li>
<li>3.了解核函数</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面，分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。它是一种监督式学习的方法，可广泛地应用于统计分类以及回归分析。支持向量机属于一般化线性分类器，这族分类器的特点是他们能够同时最小化经验误差与最大化几何边缘区。</p>
</li>
<li><p>我们需要寻找数据点到超平面的距离间隔最大，即通过几何学的知识，我们知道点 <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x"> 到超平面 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/63a5e2b53001253e0447d8ebf105843ab3873438.png" alt="(\beta, \beta_{0})"> 的距离为:</p>
<p>  <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/20140502205728468.jpg"><br>  ||w||的意思是w的二范数。</p>
<p>  刚才我们介绍了间隔(margin),这里表示为 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/5d1e4485dc90c450e8c76826516c1b2ccb8fce16.png" alt="M">, 它的取值是最近距离的2倍:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M = 2 / ||w||</span><br></pre></td></tr></table></figure>

<p>  最大化这个式子等价于最小化||w||, 另外由于||w||是一个单调函数，我们可以对其加入平方，和前面的系数，熟悉的同学应该很容易就看出来了，这个式子是为了方便求导。</p>
<p>  最大化 <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/5d1e4485dc90c450e8c76826516c1b2ccb8fce16.png" alt="M"> 转化为在附加限制条件下最小化函数：</p>
<p>  <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/20140502212218390.jpg"></p>
<p>  即：<img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/1351141837_7366.jpg"></p>
<p>  这是一个拉格朗日优化问题，可以通过拉格朗日乘数法得到最优超平面的权重向量<strong>W</strong>和偏置 <strong>b</strong> 。</p>
<p>  <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/20140502212752609.jpg"><br>  进而把寻求分类函数f(x) &#x3D; w.x + b的问题转化为对w，b的最优化问题，最终化为对偶因子的求解。</p>
</li>
<li><p>如果数据集是线性不可分的，这里可以把原始数据集映射到高维空间上，然后再找合适的划分超平面。如果原始数据集空间是有限维，即属性数是有限的，那么 一定存在一个高维特征空间使样本可分。这个属性从低维到高维的映射就是核函数。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>初步了解了支持向量机这一目前最好的现成分类器。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/dm-algo-top10/content/svm-1.html">支持向量机（SVM）</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/51a72543ebff">支持向量机（SVM）通俗理解</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/96.html">《机器学习实战》（笔记）— Logistic回归</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><h2 id="学习的内容"><a href="#学习的内容" class="headerlink" title="学习的内容"></a>学习的内容</h2><ul>
<li>1.Logistic回归案例实战</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>利用Logistic回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。训练分类器的做法就是寻找最佳拟合参数，使用的是最优化算法，这里使用梯度下降法，因为输出结果是分类形式，所以用Sigmoid函数对结果进行处理。<br>  Sigmoid函数公式为：<img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D99/sign=a46bd6f1dd33c895a27e9472d01340df/0df3d7ca7bcb0a4659502a5f6f63f6246b60af62.jpg"><br>  模型用一元函数：y &#x3D; wx</p>
<p>  下面用Logistic回归原理和具体20个特征的数据集来预测马的存活问题。<br>  具体的代码实现如下：<br>  加载数据：代码略<br>  Sigmoid函数：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">inX</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+exp(-inX))</span><br></pre></td></tr></table></figure>
<p>  随机梯度下降算法：<br>  这里采用随机形式是为了减少迭代数，加快模型收敛速度。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stocGradAscent1</span>(<span class="params">dataMatrix, classLabels, numIter=<span class="number">150</span></span>):</span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    weights = ones(n)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(numIter):</span><br><span class="line">        dataIndex = <span class="built_in">range</span>(m)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># 每次迭代时调整学习率</span></span><br><span class="line">            alpha = <span class="number">4</span>/(<span class="number">1.0</span>+j+i)+<span class="number">0.0001</span></span><br><span class="line">            <span class="comment"># 样本数据索引随机获取</span></span><br><span class="line">            randIndex = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>,<span class="built_in">len</span>(dataIndex)))</span><br><span class="line">            <span class="comment"># 梯度下降法更新模型参数</span></span><br><span class="line">            h = sigmoid(<span class="built_in">sum</span>(dataMatrix[randIndex]*weights))</span><br><span class="line">            error = classLabels[randIndex] - h</span><br><span class="line">            weights = weights + alpha * error * dataMatrix[randIndex]</span><br><span class="line">            <span class="keyword">del</span>(dataIndex[randIndex])</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure>
<p>  Logistic回归分类器：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分类函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classifyVector</span>(<span class="params">inX, weights</span>):</span><br><span class="line">    prob = sigmoid(<span class="built_in">sum</span>(inX*weights))</span><br><span class="line">    <span class="keyword">if</span> prob &gt; <span class="number">0.5</span>: <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练迭代的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">colicTest</span>():</span><br><span class="line">    frTrain = <span class="built_in">open</span>(<span class="string">&#x27;horseColicTraining.txt&#x27;</span>)</span><br><span class="line">    frTest = <span class="built_in">open</span>(<span class="string">&#x27;horseColicTest.txt&#x27;</span>)</span><br><span class="line">    trainingSet = []; trainingLabels = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTrain.readlines():</span><br><span class="line">        currLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(currLine[i]))</span><br><span class="line">        trainingSet.append(lineArr)</span><br><span class="line">        trainingLabels.append(<span class="built_in">float</span>(currLine[<span class="number">21</span>]))</span><br><span class="line">    trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, <span class="number">1000</span>)</span><br><span class="line">    errorCount = <span class="number">0</span>; numTestVec = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTest.readlines():</span><br><span class="line">        numTestVec += <span class="number">1.0</span></span><br><span class="line">        currLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(currLine[i]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(classifyVector(array(lineArr), trainWeights))!= <span class="built_in">int</span>(currLine[<span class="number">21</span>]):</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    errorRate = (<span class="built_in">float</span>(errorCount)/numTestVec)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;the error rate of this test is: %f&quot;</span> % errorRate</span><br><span class="line">    <span class="keyword">return</span> errorRate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练入口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiTest</span>():</span><br><span class="line">    numTests = <span class="number">10</span>; errorSum=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(numTests):</span><br><span class="line">        errorSum += colicTest()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;after %d iterations the average error rate is: %f&quot;</span> % (numTests, errorSum/<span class="built_in">float</span>(numTests))</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import logRegres</span><br><span class="line">&gt;&gt;&gt; logRegres.multiTest()</span><br><span class="line">logRegres.py:18: RuntimeWarning: overflow encountered in exp</span><br><span class="line">  return 1.0/(1+exp(-inX))</span><br><span class="line">the error rate of this test is: 0.343284</span><br><span class="line">the error rate of this test is: 0.268657</span><br><span class="line">the error rate of this test is: 0.373134</span><br><span class="line">the error rate of this test is: 0.373134</span><br><span class="line">the error rate of this test is: 0.388060</span><br><span class="line">the error rate of this test is: 0.373134</span><br><span class="line">the error rate of this test is: 0.432836</span><br><span class="line">the error rate of this test is: 0.298507</span><br><span class="line">the error rate of this test is: 0.417910</span><br><span class="line">the error rate of this test is: 0.388060</span><br><span class="line">after 10 iterations the average error rate is: 0.365672</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>  完整代码请查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/Ch05/logRegres.py">Logistic回归</a></p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解Logistic回归作分类器的原理及随机梯度下降的简单实现。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/95.html">《机器学习实战》（笔记）— 朴素贝叶斯</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><ul>
<li>1.了解贝叶斯公式及作用</li>
<li>2.实现朴素贝叶斯</li>
</ul>
<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><ul>
<li><p>贝叶斯是一种基于概率论的分类方法。首先需要了解什么是条件概率，它表示在某条件下事件发生的概率，写作p(c|x)，表示在x条件下，c发生的概率。贝叶斯公式为：<br>  p(c|x) &#x3D; p(x|c)p(c) &#x2F; p(x)<br>  这个公式告诉我们怎样交换条件概率中的条件与结果。实际场景中我们可以通过数据集知道在各个类别的前提下，特征的概率是多少，这样我们就能利用贝叶斯公式算出在知道样本数据特征的情况下，计算出该样本对应的各个类别的概率，然后取概率最大的作为此数据最可能的类别。</p>
</li>
<li><p>这里用贝叶斯实现对留言文本进行二分类识别。<br>  获取数据集：代码略。<br>  数据向量化：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据集里出现的词去重后放到一维向量中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVocabList</span>(<span class="params">dataSet</span>):</span><br><span class="line">    vocabSet = <span class="built_in">set</span>([])</span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        vocabSet = vocabSet | <span class="built_in">set</span>(document)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入文档inputSet转化为文档向量，此向量的每一元素为0或1，分别表示词汇表中的单词在输入文档中是否出现。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setOfWords2Vec</span>(<span class="params">vocabList, inputSet</span>):</span><br><span class="line">    returnVec = [<span class="number">0</span>]*<span class="built_in">len</span>(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="built_in">print</span> <span class="string">&quot;the word: %s is not in my Vocabulary!&quot;</span> % word</span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>
<p>  朴素贝叶斯的训练函数：<br>  为降低概率为0的影响，将所有词出现的出现数初始为1，计算的分母初始为2；为了防止条件概率的乘积导致数值下溢出为0，需要对乘积结果取自然对数。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trainNB0</span>(<span class="params">trainMatrix,trainCategory</span>):</span><br><span class="line">    numTrainDocs = <span class="built_in">len</span>(trainMatrix)</span><br><span class="line">    numWords = <span class="built_in">len</span>(trainMatrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 因为这里是二分类，所以只计算其中一个分类的概率</span></span><br><span class="line">    pAbusive = <span class="built_in">sum</span>(trainCategory)/<span class="built_in">float</span>(numTrainDocs)</span><br><span class="line">    <span class="comment"># 数据集中两个类别的概率向量，即是在某类别发生的情况下，各个词对应的条件概率</span></span><br><span class="line">    p0Num = ones(numWords); p1Num = ones(numWords)</span><br><span class="line">    p0Denom = <span class="number">2.0</span>; p1Denom = <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTrainDocs):</span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</span><br><span class="line">            p1Num += trainMatrix[i]</span><br><span class="line">            p1Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            p0Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line">    p1Vect = log(p1Num/p1Denom)</span><br><span class="line">    p0Vect = log(p0Num/p0Denom)</span><br><span class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</span><br></pre></td></tr></table></figure>
<p>  朴素贝叶斯分类函数：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classifyNB</span>(<span class="params">vec2Classify, p0Vec, p1Vec, pClass1</span>):</span><br><span class="line">    p1 = <span class="built_in">sum</span>(vec2Classify * p1Vec) + log(pClass1)</span><br><span class="line">    p0 = <span class="built_in">sum</span>(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testingNB</span>():</span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    listOPosts,listClasses = loadDataSet()</span><br><span class="line">    <span class="comment"># 数据向量化</span></span><br><span class="line">    myVocabList = createVocabList(listOPosts)</span><br><span class="line">    trainMat=[]</span><br><span class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">    <span class="comment"># 计算各类别的概率微量</span></span><br><span class="line">    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))</span><br><span class="line">    <span class="comment"># 测试样本</span></span><br><span class="line">    testEntry = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="built_in">print</span> testEntry,<span class="string">&#x27;classified as: &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br><span class="line">    testEntry = [<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="built_in">print</span> testEntry,<span class="string">&#x27;classified as: &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import bayes</span><br><span class="line">&gt;&gt;&gt; bayes.testingNB()</span><br><span class="line">[&#x27;love&#x27;, &#x27;my&#x27;, &#x27;dalmation&#x27;] classified as:  0</span><br><span class="line">[&#x27;stupid&#x27;, &#x27;garbage&#x27;] classified as:  1</span><br></pre></td></tr></table></figure>
<p>  完整代码请查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/Ch04/bayes.py">朴素贝叶斯</a></p>
</li>
</ul>
<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>了解贝叶斯这一普遍有效的概率论分类方法的原理和实现。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/94.html">《机器学习实战》（笔记）— 理解和实现决策树</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.了解信息增益</li>
<li>2.理解决策树原理</li>
<li>3.决策树的简单实现</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>信息增益是信息论中的熵，表示信息的期望值。<br>  类别C是变量，它可能的取值是C1，C2，……，Cn，而每一个类别出现的概率是P(C1)，P(C2)，……，P(Cn)，因此n就是类别的总数。此时分类系统的熵就可以表示为：<br>  <img src="https://pic002.cnblogs.com/images/2012/329131/2012052716580941.jpg"></p>
</li>
<li><p>决策树结构类似于数据结构里的二叉树，通常用来做一些分类任务，样本输入后，经过分支到达叶子节点，该节点代表的分类就是样本数据的识别类别。训练就是构造决策树的过程，节点是由特征来决定的，而特征选用的顺序需要由信息增益（即信息论中的熵）来决定，哪个特征能使信息增益增大（即熵值减小），就先使用该特征作为分支条件，这样递归下去就得到了整棵决策树。</p>
</li>
<li><p>创建数据集：每个样本都是一个三维数组，前两维分别表示两种特征的数值，最后一个元素表示此样本所属类别。代码略。<br>  计算数据集的信息熵：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 数据集总样本数量</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    <span class="comment"># 计算数据集里各个类别的样本数量</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 根据公式计算些数据集的信息熵</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key])/numEntries</span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure>
<p>  划分节点的数据集：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="comment"># 遍历父数据集，找出axis对应的分类value数据，返回新的子节点数据集</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]</span><br><span class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure>
<p>  选择最好的数据集划分方式：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 计算数据集的特征数量</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算数据集的信息熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line"></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>; bestFeature = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 创建具有某特征的值列表，且去重</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment"># 划分特征节点的数据集</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 计算此特征节点数据集的信息熵</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet)/<span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)     </span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="comment"># 拿到最小的信息熵，并记录该特征</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="comment"># 返回能使数据集信息熵最小的特征</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>
<p>  递归构建决策树：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet,labels</span>):</span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 类别完全相同则直接返回该类别</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList): </span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 遍历完所有特征时返回出现次数最多的类别</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    <span class="comment"># 获取最佳节点特征并赋给决策树节点</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    <span class="comment"># 得到列表包含的所有特征值，并进行递归构建决策树</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = <span class="built_in">set</span>(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import trees</span><br><span class="line">&gt;&gt;&gt; myDat, labels = trees.createDataSet()</span><br><span class="line">&gt;&gt;&gt; myTree = trees.createTree(myDat, labels)</span><br><span class="line">&gt;&gt;&gt; myTree</span><br><span class="line">&#123;&#x27;no surfacing&#x27;: &#123;0: &#x27;no&#x27;, 1: &#123;&#x27;flippers&#x27;: &#123;0: &#x27;no&#x27;, 1: &#x27;yes&#x27;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>  完整代码请查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/Ch03/trees.py">决策树的实现</a></p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解了信息熵的定义和计算公式，对机器学习的分类算法决策树有了一定的理解。</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/93.html">《机器学习实战》（笔记）— k-近邻算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="k-近邻算法"></a>k-近邻算法</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.理解k-近邻算法的原理</li>
<li>2.k-近邻算法的实现</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>k-近邻算法一定作为分类识别，是一种较为简单直接的算法。将待识别的数据特征与数据集里的特征进行比较，通过一定规则算出与所有样本的距离，选取k个最相近的数据（通常k不大于20），k个最相似数据中出现次数最多的分类，就作为待识别数据的分类。<br>  虽然这种算法精度高、对异常值不敏感，然而也存在计算复杂度高的缺点。</p>
</li>
<li><p>下面作一个k-近邻算法的简单示例：<br>  创建一个含有4个向量、分别属于AB两类的数据集：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">    group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">    labels = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> group, labels</span><br></pre></td></tr></table></figure>
<p>  kNN分类算法实现：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classify0</span>(<span class="params">inX, dataSet, labels, k</span>):</span><br><span class="line">    <span class="comment"># 待识别数据与数据集每个样本的距离计算</span></span><br><span class="line">    <span class="comment"># 距离的计算使用欧氏距离公式</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistances = sqDiffMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()     </span><br><span class="line">    classCount=&#123;&#125;  </span><br><span class="line">    <span class="comment"># 获取距离最小的k个点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 使用operator模块的itemgetter方法，排序并返回发生频率最高的元素标签</span></span><br><span class="line">    sortedClassCount = <span class="built_in">sorted</span>(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  运行效果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import kNN</span><br><span class="line">&gt;&gt;&gt; kNN.classify0([0,0], group, labels, 3)</span><br><span class="line">&#x27;B&#x27;</span><br></pre></td></tr></table></figure>
<p>  完整代码实现可查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/kNN.py">kNN</a>，或者直接阅读<a target="_blank" rel="noopener" href="https://www.manning.com/books/machine-learning-in-action">《机器学习实战》</a>第2章内容。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>理解并实现了kNN分类算法，掌握了这一简单直接的机器学习算法原理。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/92.html">了解极大似然估计</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>了解极大似然估计原理</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>因为某些场景的整体数据量过大，要分析其中某些情况出现的概率，就可以用极大似然估计，这样的情况在机器学习算法中频繁出现。下面用一个简单的例子来解析它：<br>  <img src="http://img.blog.csdn.net/20170528002827749" alt="Minion"><br>  这就是它最直观的原理讲解了。<br>  极大似然估计是建立在极大似然原理的基础上的一个统计方法，是概率论在统计学中的应用。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。<br>  然而在一些复杂的条件下，是很难通过直观的方式获得答案的，这时候理论分析就尤为重要了，这也是学者们为何要提出最大似然估计的原因。</p>
<p>  由于样本集中的样本都是独立同分布，可以只考虑一类样本集D，来估计参数向量θ。记已知的样本集为：</p>
<p>  <img src="http://img.blog.csdn.net/20170528003138251">  </p>
<p>  似然函数（linkehood function）：联合概率密度函数<img src="http://img.blog.csdn.net/20170528003212360">称为相对于<img src="http://img.blog.csdn.net/20170528003218392">的θ的似然函数。</p>
<p>  <img src="http://img.blog.csdn.net/20170528003223845"><br>  如果<img src="http://img.blog.csdn.net/20170528003231366">是参数空间中能使似然函数<img src="http://img.blog.csdn.net/20170528003236220">最大的θ值，则<img src="http://img.blog.csdn.net/20170528003231366">应该是“最可能”的参数值，那么<img src="http://img.blog.csdn.net/20170528003231366">就是θ的极大似然估计量<br>  因为事件已经发生，所以要使它发生的概率<img src="http://img.blog.csdn.net/20170528003212360">最大，这就可以转换为求极大似然函数的最大值，接下来就是求对数（简化求解过程），求导求最值。求解大概流程如下：<br>  求最大似然估计量<img src="http://img.blog.csdn.net/20170528003231366">的一般步骤：</p>
<p>  （1）写出似然函数；</p>
<p>  （2）对似然函数取对数，并整理；</p>
<p>  （3）求导数；</p>
<p>  （4）解似然方程。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解了极大似然估计怎样利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值。这也是平时生活中一些抽样检查的原理依据，比如人口普查；还有用在机器学习算法里的一些概率形式的数据也是用这种方法获得的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zengxiantao1994/article/details/72787849">极大似然估计详解</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By 杨润炜</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>