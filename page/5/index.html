<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="杨润炜"><meta name="copyright" content="杨润炜"><title>Cwalker</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">杨润炜</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">137</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cwalker</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Cwalker</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/a/97.html">了解支持向量机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="了解支持向量机"><a href="#了解支持向量机" class="headerlink" title="了解支持向量机"></a>了解支持向量机</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.什么是支持向量机</li>
<li>2.如何寻找最大间隔</li>
<li>3.了解核函数</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面，分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。它是一种监督式学习的方法，可广泛地应用于统计分类以及回归分析。支持向量机属于一般化线性分类器，这族分类器的特点是他们能够同时最小化经验误差与最大化几何边缘区。</p>
</li>
<li><p>我们需要寻找数据点到超平面的距离间隔最大，即通过几何学的知识，我们知道点 <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x"> 到超平面 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/63a5e2b53001253e0447d8ebf105843ab3873438.png" alt="(\beta, \beta_{0})"> 的距离为:</p>
<p>  <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/20140502205728468.jpg"><br>  ||w||的意思是w的二范数。</p>
<p>  刚才我们介绍了间隔(margin),这里表示为 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/5d1e4485dc90c450e8c76826516c1b2ccb8fce16.png" alt="M">, 它的取值是最近距离的2倍:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M = 2 / ||w||</span><br></pre></td></tr></table></figure>

<p>  最大化这个式子等价于最小化||w||, 另外由于||w||是一个单调函数，我们可以对其加入平方，和前面的系数，熟悉的同学应该很容易就看出来了，这个式子是为了方便求导。</p>
<p>  最大化 <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/5d1e4485dc90c450e8c76826516c1b2ccb8fce16.png" alt="M"> 转化为在附加限制条件下最小化函数：</p>
<p>  <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/20140502212218390.jpg"></p>
<p>  即：<img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/1351141837_7366.jpg"></p>
<p>  这是一个拉格朗日优化问题，可以通过拉格朗日乘数法得到最优超平面的权重向量<strong>W</strong>和偏置 <strong>b</strong> 。</p>
<p>  <img src="https://wizardforcel.gitbooks.io/dm-algo-top10/content/img/20140502212752609.jpg"><br>  进而把寻求分类函数f(x) &#x3D; w.x + b的问题转化为对w，b的最优化问题，最终化为对偶因子的求解。</p>
</li>
<li><p>如果数据集是线性不可分的，这里可以把原始数据集映射到高维空间上，然后再找合适的划分超平面。如果原始数据集空间是有限维，即属性数是有限的，那么 一定存在一个高维特征空间使样本可分。这个属性从低维到高维的映射就是核函数。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>初步了解了支持向量机这一目前最好的现成分类器。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/dm-algo-top10/content/svm-1.html">支持向量机（SVM）</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/51a72543ebff">支持向量机（SVM）通俗理解</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/96.html">《机器学习实战》（笔记）— Logistic回归</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><h2 id="学习的内容"><a href="#学习的内容" class="headerlink" title="学习的内容"></a>学习的内容</h2><ul>
<li>1.Logistic回归案例实战</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>利用Logistic回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。训练分类器的做法就是寻找最佳拟合参数，使用的是最优化算法，这里使用梯度下降法，因为输出结果是分类形式，所以用Sigmoid函数对结果进行处理。<br>  Sigmoid函数公式为：<img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D99/sign=a46bd6f1dd33c895a27e9472d01340df/0df3d7ca7bcb0a4659502a5f6f63f6246b60af62.jpg"><br>  模型用一元函数：y &#x3D; wx</p>
<p>  下面用Logistic回归原理和具体20个特征的数据集来预测马的存活问题。<br>  具体的代码实现如下：<br>  加载数据：代码略<br>  Sigmoid函数：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">inX</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+exp(-inX))</span><br></pre></td></tr></table></figure>
<p>  随机梯度下降算法：<br>  这里采用随机形式是为了减少迭代数，加快模型收敛速度。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stocGradAscent1</span>(<span class="params">dataMatrix, classLabels, numIter=<span class="number">150</span></span>):</span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    weights = ones(n)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(numIter):</span><br><span class="line">        dataIndex = <span class="built_in">range</span>(m)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># 每次迭代时调整学习率</span></span><br><span class="line">            alpha = <span class="number">4</span>/(<span class="number">1.0</span>+j+i)+<span class="number">0.0001</span></span><br><span class="line">            <span class="comment"># 样本数据索引随机获取</span></span><br><span class="line">            randIndex = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>,<span class="built_in">len</span>(dataIndex)))</span><br><span class="line">            <span class="comment"># 梯度下降法更新模型参数</span></span><br><span class="line">            h = sigmoid(<span class="built_in">sum</span>(dataMatrix[randIndex]*weights))</span><br><span class="line">            error = classLabels[randIndex] - h</span><br><span class="line">            weights = weights + alpha * error * dataMatrix[randIndex]</span><br><span class="line">            <span class="keyword">del</span>(dataIndex[randIndex])</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure>
<p>  Logistic回归分类器：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分类函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classifyVector</span>(<span class="params">inX, weights</span>):</span><br><span class="line">    prob = sigmoid(<span class="built_in">sum</span>(inX*weights))</span><br><span class="line">    <span class="keyword">if</span> prob &gt; <span class="number">0.5</span>: <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练迭代的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">colicTest</span>():</span><br><span class="line">    frTrain = <span class="built_in">open</span>(<span class="string">&#x27;horseColicTraining.txt&#x27;</span>)</span><br><span class="line">    frTest = <span class="built_in">open</span>(<span class="string">&#x27;horseColicTest.txt&#x27;</span>)</span><br><span class="line">    trainingSet = []; trainingLabels = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTrain.readlines():</span><br><span class="line">        currLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(currLine[i]))</span><br><span class="line">        trainingSet.append(lineArr)</span><br><span class="line">        trainingLabels.append(<span class="built_in">float</span>(currLine[<span class="number">21</span>]))</span><br><span class="line">    trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, <span class="number">1000</span>)</span><br><span class="line">    errorCount = <span class="number">0</span>; numTestVec = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTest.readlines():</span><br><span class="line">        numTestVec += <span class="number">1.0</span></span><br><span class="line">        currLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(currLine[i]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(classifyVector(array(lineArr), trainWeights))!= <span class="built_in">int</span>(currLine[<span class="number">21</span>]):</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    errorRate = (<span class="built_in">float</span>(errorCount)/numTestVec)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;the error rate of this test is: %f&quot;</span> % errorRate</span><br><span class="line">    <span class="keyword">return</span> errorRate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练入口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiTest</span>():</span><br><span class="line">    numTests = <span class="number">10</span>; errorSum=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(numTests):</span><br><span class="line">        errorSum += colicTest()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;after %d iterations the average error rate is: %f&quot;</span> % (numTests, errorSum/<span class="built_in">float</span>(numTests))</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import logRegres</span><br><span class="line">&gt;&gt;&gt; logRegres.multiTest()</span><br><span class="line">logRegres.py:18: RuntimeWarning: overflow encountered in exp</span><br><span class="line">  return 1.0/(1+exp(-inX))</span><br><span class="line">the error rate of this test is: 0.343284</span><br><span class="line">the error rate of this test is: 0.268657</span><br><span class="line">the error rate of this test is: 0.373134</span><br><span class="line">the error rate of this test is: 0.373134</span><br><span class="line">the error rate of this test is: 0.388060</span><br><span class="line">the error rate of this test is: 0.373134</span><br><span class="line">the error rate of this test is: 0.432836</span><br><span class="line">the error rate of this test is: 0.298507</span><br><span class="line">the error rate of this test is: 0.417910</span><br><span class="line">the error rate of this test is: 0.388060</span><br><span class="line">after 10 iterations the average error rate is: 0.365672</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>  完整代码请查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/Ch05/logRegres.py">Logistic回归</a></p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解Logistic回归作分类器的原理及随机梯度下降的简单实现。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/95.html">《机器学习实战》（笔记）— 朴素贝叶斯</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><ul>
<li>1.了解贝叶斯公式及作用</li>
<li>2.实现朴素贝叶斯</li>
</ul>
<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><ul>
<li><p>贝叶斯是一种基于概率论的分类方法。首先需要了解什么是条件概率，它表示在某条件下事件发生的概率，写作p(c|x)，表示在x条件下，c发生的概率。贝叶斯公式为：<br>  p(c|x) &#x3D; p(x|c)p(c) &#x2F; p(x)<br>  这个公式告诉我们怎样交换条件概率中的条件与结果。实际场景中我们可以通过数据集知道在各个类别的前提下，特征的概率是多少，这样我们就能利用贝叶斯公式算出在知道样本数据特征的情况下，计算出该样本对应的各个类别的概率，然后取概率最大的作为此数据最可能的类别。</p>
</li>
<li><p>这里用贝叶斯实现对留言文本进行二分类识别。<br>  获取数据集：代码略。<br>  数据向量化：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据集里出现的词去重后放到一维向量中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVocabList</span>(<span class="params">dataSet</span>):</span><br><span class="line">    vocabSet = <span class="built_in">set</span>([])</span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        vocabSet = vocabSet | <span class="built_in">set</span>(document)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入文档inputSet转化为文档向量，此向量的每一元素为0或1，分别表示词汇表中的单词在输入文档中是否出现。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setOfWords2Vec</span>(<span class="params">vocabList, inputSet</span>):</span><br><span class="line">    returnVec = [<span class="number">0</span>]*<span class="built_in">len</span>(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="built_in">print</span> <span class="string">&quot;the word: %s is not in my Vocabulary!&quot;</span> % word</span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>
<p>  朴素贝叶斯的训练函数：<br>  为降低概率为0的影响，将所有词出现的出现数初始为1，计算的分母初始为2；为了防止条件概率的乘积导致数值下溢出为0，需要对乘积结果取自然对数。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trainNB0</span>(<span class="params">trainMatrix,trainCategory</span>):</span><br><span class="line">    numTrainDocs = <span class="built_in">len</span>(trainMatrix)</span><br><span class="line">    numWords = <span class="built_in">len</span>(trainMatrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 因为这里是二分类，所以只计算其中一个分类的概率</span></span><br><span class="line">    pAbusive = <span class="built_in">sum</span>(trainCategory)/<span class="built_in">float</span>(numTrainDocs)</span><br><span class="line">    <span class="comment"># 数据集中两个类别的概率向量，即是在某类别发生的情况下，各个词对应的条件概率</span></span><br><span class="line">    p0Num = ones(numWords); p1Num = ones(numWords)</span><br><span class="line">    p0Denom = <span class="number">2.0</span>; p1Denom = <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTrainDocs):</span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</span><br><span class="line">            p1Num += trainMatrix[i]</span><br><span class="line">            p1Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            p0Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line">    p1Vect = log(p1Num/p1Denom)</span><br><span class="line">    p0Vect = log(p0Num/p0Denom)</span><br><span class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</span><br></pre></td></tr></table></figure>
<p>  朴素贝叶斯分类函数：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classifyNB</span>(<span class="params">vec2Classify, p0Vec, p1Vec, pClass1</span>):</span><br><span class="line">    p1 = <span class="built_in">sum</span>(vec2Classify * p1Vec) + log(pClass1)</span><br><span class="line">    p0 = <span class="built_in">sum</span>(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testingNB</span>():</span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    listOPosts,listClasses = loadDataSet()</span><br><span class="line">    <span class="comment"># 数据向量化</span></span><br><span class="line">    myVocabList = createVocabList(listOPosts)</span><br><span class="line">    trainMat=[]</span><br><span class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">    <span class="comment"># 计算各类别的概率微量</span></span><br><span class="line">    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))</span><br><span class="line">    <span class="comment"># 测试样本</span></span><br><span class="line">    testEntry = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="built_in">print</span> testEntry,<span class="string">&#x27;classified as: &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br><span class="line">    testEntry = [<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="built_in">print</span> testEntry,<span class="string">&#x27;classified as: &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import bayes</span><br><span class="line">&gt;&gt;&gt; bayes.testingNB()</span><br><span class="line">[&#x27;love&#x27;, &#x27;my&#x27;, &#x27;dalmation&#x27;] classified as:  0</span><br><span class="line">[&#x27;stupid&#x27;, &#x27;garbage&#x27;] classified as:  1</span><br></pre></td></tr></table></figure>
<p>  完整代码请查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/Ch04/bayes.py">朴素贝叶斯</a></p>
</li>
</ul>
<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>了解贝叶斯这一普遍有效的概率论分类方法的原理和实现。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/94.html">《机器学习实战》（笔记）— 理解和实现决策树</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.了解信息增益</li>
<li>2.理解决策树原理</li>
<li>3.决策树的简单实现</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>信息增益是信息论中的熵，表示信息的期望值。<br>  类别C是变量，它可能的取值是C1，C2，……，Cn，而每一个类别出现的概率是P(C1)，P(C2)，……，P(Cn)，因此n就是类别的总数。此时分类系统的熵就可以表示为：<br>  <img src="https://pic002.cnblogs.com/images/2012/329131/2012052716580941.jpg"></p>
</li>
<li><p>决策树结构类似于数据结构里的二叉树，通常用来做一些分类任务，样本输入后，经过分支到达叶子节点，该节点代表的分类就是样本数据的识别类别。训练就是构造决策树的过程，节点是由特征来决定的，而特征选用的顺序需要由信息增益（即信息论中的熵）来决定，哪个特征能使信息增益增大（即熵值减小），就先使用该特征作为分支条件，这样递归下去就得到了整棵决策树。</p>
</li>
<li><p>创建数据集：每个样本都是一个三维数组，前两维分别表示两种特征的数值，最后一个元素表示此样本所属类别。代码略。<br>  计算数据集的信息熵：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 数据集总样本数量</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    <span class="comment"># 计算数据集里各个类别的样本数量</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 根据公式计算些数据集的信息熵</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key])/numEntries</span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure>
<p>  划分节点的数据集：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="comment"># 遍历父数据集，找出axis对应的分类value数据，返回新的子节点数据集</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]</span><br><span class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure>
<p>  选择最好的数据集划分方式：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 计算数据集的特征数量</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算数据集的信息熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line"></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>; bestFeature = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 创建具有某特征的值列表，且去重</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment"># 划分特征节点的数据集</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 计算此特征节点数据集的信息熵</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet)/<span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)     </span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="comment"># 拿到最小的信息熵，并记录该特征</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="comment"># 返回能使数据集信息熵最小的特征</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>
<p>  递归构建决策树：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet,labels</span>):</span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 类别完全相同则直接返回该类别</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList): </span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 遍历完所有特征时返回出现次数最多的类别</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    <span class="comment"># 获取最佳节点特征并赋给决策树节点</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    <span class="comment"># 得到列表包含的所有特征值，并进行递归构建决策树</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = <span class="built_in">set</span>(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import trees</span><br><span class="line">&gt;&gt;&gt; myDat, labels = trees.createDataSet()</span><br><span class="line">&gt;&gt;&gt; myTree = trees.createTree(myDat, labels)</span><br><span class="line">&gt;&gt;&gt; myTree</span><br><span class="line">&#123;&#x27;no surfacing&#x27;: &#123;0: &#x27;no&#x27;, 1: &#123;&#x27;flippers&#x27;: &#123;0: &#x27;no&#x27;, 1: &#x27;yes&#x27;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>  完整代码请查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/Ch03/trees.py">决策树的实现</a></p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解了信息熵的定义和计算公式，对机器学习的分类算法决策树有了一定的理解。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/93.html">《机器学习实战》（笔记）— k-近邻算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="k-近邻算法"></a>k-近邻算法</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.理解k-近邻算法的原理</li>
<li>2.k-近邻算法的实现</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>k-近邻算法一定作为分类识别，是一种较为简单直接的算法。将待识别的数据特征与数据集里的特征进行比较，通过一定规则算出与所有样本的距离，选取k个最相近的数据（通常k不大于20），k个最相似数据中出现次数最多的分类，就作为待识别数据的分类。<br>  虽然这种算法精度高、对异常值不敏感，然而也存在计算复杂度高的缺点。</p>
</li>
<li><p>下面作一个k-近邻算法的简单示例：<br>  创建一个含有4个向量、分别属于AB两类的数据集：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">    group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">    labels = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> group, labels</span><br></pre></td></tr></table></figure>
<p>  kNN分类算法实现：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classify0</span>(<span class="params">inX, dataSet, labels, k</span>):</span><br><span class="line">    <span class="comment"># 待识别数据与数据集每个样本的距离计算</span></span><br><span class="line">    <span class="comment"># 距离的计算使用欧氏距离公式</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistances = sqDiffMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()     </span><br><span class="line">    classCount=&#123;&#125;  </span><br><span class="line">    <span class="comment"># 获取距离最小的k个点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 使用operator模块的itemgetter方法，排序并返回发生频率最高的元素标签</span></span><br><span class="line">    sortedClassCount = <span class="built_in">sorted</span>(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  运行效果：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import kNN</span><br><span class="line">&gt;&gt;&gt; kNN.classify0([0,0], group, labels, 3)</span><br><span class="line">&#x27;B&#x27;</span><br></pre></td></tr></table></figure>
<p>  完整代码实现可查看：<a target="_blank" rel="noopener" href="https://github.com/pauky/machine_learning_in_action/blob/master/kNN.py">kNN</a>，或者直接阅读<a target="_blank" rel="noopener" href="https://www.manning.com/books/machine-learning-in-action">《机器学习实战》</a>第2章内容。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>理解并实现了kNN分类算法，掌握了这一简单直接的机器学习算法原理。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/92.html">了解极大似然估计</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>了解极大似然估计原理</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>因为某些场景的整体数据量过大，要分析其中某些情况出现的概率，就可以用极大似然估计，这样的情况在机器学习算法中频繁出现。下面用一个简单的例子来解析它：<br>  <img src="http://img.blog.csdn.net/20170528002827749" alt="Minion"><br>  这就是它最直观的原理讲解了。<br>  极大似然估计是建立在极大似然原理的基础上的一个统计方法，是概率论在统计学中的应用。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。<br>  然而在一些复杂的条件下，是很难通过直观的方式获得答案的，这时候理论分析就尤为重要了，这也是学者们为何要提出最大似然估计的原因。</p>
<p>  由于样本集中的样本都是独立同分布，可以只考虑一类样本集D，来估计参数向量θ。记已知的样本集为：</p>
<p>  <img src="http://img.blog.csdn.net/20170528003138251">  </p>
<p>  似然函数（linkehood function）：联合概率密度函数<img src="http://img.blog.csdn.net/20170528003212360">称为相对于<img src="http://img.blog.csdn.net/20170528003218392">的θ的似然函数。</p>
<p>  <img src="http://img.blog.csdn.net/20170528003223845"><br>  如果<img src="http://img.blog.csdn.net/20170528003231366">是参数空间中能使似然函数<img src="http://img.blog.csdn.net/20170528003236220">最大的θ值，则<img src="http://img.blog.csdn.net/20170528003231366">应该是“最可能”的参数值，那么<img src="http://img.blog.csdn.net/20170528003231366">就是θ的极大似然估计量<br>  因为事件已经发生，所以要使它发生的概率<img src="http://img.blog.csdn.net/20170528003212360">最大，这就可以转换为求极大似然函数的最大值，接下来就是求对数（简化求解过程），求导求最值。求解大概流程如下：<br>  求最大似然估计量<img src="http://img.blog.csdn.net/20170528003231366">的一般步骤：</p>
<p>  （1）写出似然函数；</p>
<p>  （2）对似然函数取对数，并整理；</p>
<p>  （3）求导数；</p>
<p>  （4）解似然方程。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解了极大似然估计怎样利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值。这也是平时生活中一些抽样检查的原理依据，比如人口普查；还有用在机器学习算法里的一些概率形式的数据也是用这种方法获得的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zengxiantao1994/article/details/72787849">极大似然估计详解</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/90.html">动手学深度学习（笔记）- 卷积神经网络</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.什么是卷积神经网络</li>
<li>2.为什么要使用卷积神经网络</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>卷积神经网络除了包含普通神经网络的输入输出层、激励层、隐含层之外，还有两种特殊的结构：卷积计算层和池化层；<br>  卷积计算层：用于线性乘积 求和；<br>  了解卷积神经网络，首先要了解什么是卷积：<br>  对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做<strong>内积</strong>（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源；举个具体的例子。比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter，图中右边是输出的新的二维数据：<br>  <img src="http://img.blog.csdn.net/20160702215705128" alt="Minion"><br>  中间滤波器filter与数据窗口做内积，其具体计算过程则是：4*0 + 0*0 + 0*0 + 0*0 + 0*1 + 0*1 + 0*0 + 0*1 + -4*2 &#x3D; -8;<br>  池化层：取区域平均或最大；<br>  下面举个简单的池化例子：<br>  <img src="http://img.blog.csdn.net/20160703121026432" alt="Minion"><br>  上图所展示的是取区域最大，即上图左边部分中 左上角2x2的矩阵中6最大，右上角2x2的矩阵中8最大，左下角2x2的矩阵中3最大，右下角2x2的矩阵中4最大，所以得到上图右边部分的结果：6 8 3 4;</p>
</li>
<li><p>卷积层的两个要点：<strong>局部连接（Local Connection）</strong>和<strong>权值共享（Weight Sharing）</strong>;<br>  局部连接和权值共享降低了参数量，使训练复杂度大大下降，并减轻了过拟合。同时权值共享还赋予了卷积网络对平移的容忍性;<br>  池化层的降采样输出参数量，并赋予了模型对轻度形变的容忍性，提高了模型的泛化能力;<br>  相比较其他深度、前馈神经网路，卷积神经网路需要考量的参数更少。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解了对图像识别更友好有效的卷积神经网络的基本组成结构和实现原理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zh.gluon.ai/chapter_convolutional-neural-networks/cnn-scratch.html">动手学深度学习-卷积神经网络</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/v_july_v/article/details/51812459">通俗理解卷积神经网络</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/91.html">认识循环神经网络</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>了解循环神经网络</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li><p>先从基本的循环神经网络说起，它只包含一个隐含层，结构如下：<br>  <img src="http://upload-images.jianshu.io/upload_images/2256672-cf18bb1f06e750a4.jpg" alt="Minion"><br>  与之前所说的全连接神经网络的区别在于隐含层多了带箭头权重为w的圆圈；<br>  图中各部分解析如下：<br>  x是一个向量，它表示<strong>输入层</strong>的值；<br>  s是一个向量，它表示<strong>隐藏层</strong>的值；<br>  U是输入层到隐藏层的<strong>权重矩阵</strong>；<br>  o也是一个向量，它表示<strong>输出层</strong>的值；<br>  V是隐藏层到输出层的<strong>权重矩阵</strong>；<br>  W就是<strong>隐藏层</strong>上一次的值作为这一次的输入的权重；</p>
<p>  从图右侧计算流程看出，这个网络在t时刻接收到输入xt之后，隐藏层的值是st，输出值是ot。关键一点是，st的值不仅仅取决于xt，还取决于st-1。我们可以用下面的公式来表示<strong>循环神经网络</strong>的计算方法：</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/1667471-55cef3bda3b88ee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/206" alt="Minion"><br>  将第二个式子不断代入第一个式，得到：<br>  <img src="https://upload-images.jianshu.io/upload_images/1667471-a3efd4e7588c38fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/553" alt="Minion"><br>  <strong>循环神经网络</strong>的输出值   ，是受前面历次输入值的影响的，这就是<strong>循环神经网络</strong>可以往前看任意多个<strong>输入值</strong>的原因。</p>
<p>  接下来简单认识下<strong>双向循环神经网络</strong>，大体流程如下图：<br>  <img src="http://upload-images.jianshu.io/upload_images/2256672-039a45251aa5d220.png" alt="Minion"><br>  从上图可以看出，<strong>双向卷积神经网络</strong>的隐藏层要保存两个值，一个A参与正向计算，另一个值A’参与反向计算。最终的输出值取决于A2和A2’，两者分别是正向计算和反向计算的结果，所以双向循环神经网络可以向前和向后看任意个输入值。</p>
<p>  最后再来看看<strong>深度循环神经网络</strong>，它是在基本循环神经网络的单层隐含层转变为多隐含层，而且隐含层之间存在输入输出联系，如下图所示：<br>  <img src="http://upload-images.jianshu.io/upload_images/2256672-df137de8007c3d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="Minion"></p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解了几种循环神经网络的基本实现原理，以及它适合自然语言处理和机器翻译的原因。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zybuluo.com/hanbingtao/note/541458">零基础入门深度学习(5) - 循环神经网络</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/89.html">动手学深度学习（笔记）- 监督学习之正则化的多层感知机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="正则化的多层感知机"><a href="#正则化的多层感知机" class="headerlink" title="正则化的多层感知机"></a>正则化的多层感知机</h1><h2 id="学习的内容"><a href="#学习的内容" class="headerlink" title="学习的内容"></a>学习的内容</h2><ul>
<li>1.理解L2范数正则化原理</li>
<li>2.了解正则化的多层感知机结构</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><ul>
<li>以线性回归中的梯度下降法为例。假设要求的参数为θ，LOSS是我们的损失函数，那么线性回归的代价函数如下：</li>
</ul>
<p>$$<br>J (θ)&#x3D;LOSS<br>$$</p>
<p>其中loss是损失函数是以θ求导的导数函数，那么在梯度下降法中，最终用于迭代计算参数 θ 的迭代式为：</p>
<p>$$<br>θj :&#x3D;θj − loss<br>$$</p>
<p>其中 α 是学习率，m是训练数据数量。上式是没有添加L2正则化项的迭代公式，如果在原始代价函数之后添加L2正则化，则迭代公式会变成下面的样子：</p>
<p>$$<br>θj :&#x3D;θj (1−{αλ&#x2F;m}  )−loss<br>$$</p>
<p>其中λ  就是正则化参数。从上式可以看到，与未添加L2正则化的迭代公式相比，每一次迭代， θj   都要先乘以一个小于1的因子，从而使得 θ j   不断减小，因此总得来看， θ是不断减小的。在神经网络中，参数越小抗扰动能力越强，可以极大程度地降低噪声数据的影响，所以能防止过拟合的情况出现。</p>
<ul>
<li>正则化的多层感知机结构如下：<br><img src="https://zh.gluon.ai/_images/backprop.svg" alt="Minion"><br>其中各个节点的解析如下：<br>x表示输入；<br>o表示当前参数模型在正则化前的输出；<br>y表示当前输入对应的实际输出数据；<br>z表示输入数据与第一个参数的运算结果；<br>h表示神经网络隐藏层；<br>W (1)和W(2)都是所要求的神经网络参数；<br>s表示参数的L2范数正则化；<br>L表示正则化前的损失运算值；<br>J表示加入正则后的损失运算值；<br>此结构图清晰地展示了正则化的多层感知机训练流程。</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>理解了正则化解决过拟合的原理，并且从正则化多层感知机结构图中更加定性地了解到神经网络的训练过程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zh.gluon.ai/chapter_supervised-learning/backprop.html">动手学深度学习-正向传播与反向传播</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jinping_shi/article/details/52433975">机器学习中正则化项L1和L2的直观理解</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/88.html">动手学深度学习（笔记）- 监督学习之正则化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ml/">ml</a></span><div class="content"><h1 id="监督学习之正则化"><a href="#监督学习之正则化" class="headerlink" title="监督学习之正则化"></a>监督学习之正则化</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul>
<li>1.什么是训练误差和泛化误差</li>
<li>2.了解欠拟合与过拟合</li>
<li>3.了解正则化</li>
</ul>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li><p>训练误差是机器学习模型在训练数据集上表现出的误差，测试误差是模型在测试集上表现出的误差，而泛化误差指的是模型在任意一个测试数据样本上表现出的误差的期望值，泛化误差越小，模型效果才越符合实际要求；</p>
</li>
<li><p><strong>欠拟合</strong>：机器学习模型无法得到较低训练误差，往往是由于选用的模型参数过少，导致无法拟合现有训练数据的某些特征；<br>  <strong>过拟合</strong>：机器学习模型的训练误差远小于其在测试数据集上的误差，可能是由于选用的模型参数过多，或者是训练数据远少于数据的特征数量；</p>
</li>
<li><p>正则化是解决过拟合的方法之一，正则化是对较大的绝对值的参数实施了一个惩罚规则，防止一些噪声数据对某些特征影响过大而使模型参数过度拟合这些影响；除了正则化，增加训练数据和选取合适的模型（如：过度拟合时可适当减少参数数量）来解决过度拟合问题，但如果是选用的特征是无法减少的，比如考虑房价的规律，那影响的因素就很多，而正则化可以让我们既不用减少特征参数，又能让所有的影响因素都考虑到模型里，而且让影响小的因素占的权重小。</p>
</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>了解了模型训练过程中可能出现的一些异常情况和其中的一些优化方法。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By 杨润炜</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>