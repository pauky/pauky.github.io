<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="杨润炜"><meta name="copyright" content="杨润炜"><title>Cwalker</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">杨润炜</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">135</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cwalker</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Cwalker</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/a/45.html">node.js切换到稳定版本</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/qianlizhixing/">qianlizhixing</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/node-js/">node.js</a></span><div class="content"><p>之前本站一直使用的是node.js较新版本的5.0。但是命令行下面总是有乱码的情况出现，所以打算切换到v4.4.0稳定版本。在测试环境下正常运行之后，便着手在服务器上切换版本。我是用wget从node.js官网上下载了编译好的包。其实也可以下载源码来编译，道理一样。</p>
<h2 id="获取node-js"><a href="#获取node-js" class="headerlink" title="获取node.js"></a>获取node.js</h2><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v4.4.0/node-v4.4.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>

<h5 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf node-v4.4.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下载完放到&#x2F;opt&#x2F;node目录下。之后是修改linux的环境变量。</p>
<h5 id="方法1：修改profile"><a href="#方法1：修改profile" class="headerlink" title="方法1：修改profile"></a>方法1：修改profile</h5><p>先执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>然后在文件末尾加上下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import node.js</span><br><span class="line">NODE_PATH=&quot;/opt/node/node-v4.4.0/lib/node_modules&quot;</span><br><span class="line">PATH=&quot;$PATH:/opt/node/node-v4.4.0/bin&quot;</span><br><span class="line">export PATH</span><br><span class="line">export NODE_PATH</span><br></pre></td></tr></table></figure>
<p>这里表示修改linux全局变量$PATH，及增加全局变量$NODE_PATH，这个是给node.js安装和使用全局模块时使用的。</p>
<h5 id="方法2-增加node及npm链接"><a href="#方法2-增加node及npm链接" class="headerlink" title="方法2:增加node及npm链接"></a>方法2:增加node及npm链接</h5><p>还是需要修改profil，只是不需要修改$PATH变量而已：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#import node.js</span><br><span class="line">NODE_PATH=&quot;/opt/node/node-v4.4.0/lib/node_modules&quot;</span><br><span class="line">export NODE_PATH</span><br></pre></td></tr></table></figure>
<p>执行命令时，&#x2F;usr&#x2F;bin是默认寻找的目录，所以最好把node和npm的执行文件链接到这里目录里。<br>执行以上命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/node/node-v4.4.0/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /opt/node/node-v4.4.0/bin/npm /usr/bin/npm</span><br></pre></td></tr></table></figure>
<p>注意：建立链接时需要采用绝对路径，如果使用相对路径，会出现诸如：“Too many levels of symbolic links”之类的错误。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/44.html">mongodb做网站pv统计</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mongodb/">mongodb</a></span><div class="content"><p>这周做了公司给的门户网站pv统计的任务，主要是运用了mongodb聚合查询对大量数据的运算及统计，在这里记录下我的做法。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>首先要来了解下这个日志表的结构及数据量。</p>
<h5 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h5><p>accessArticle文档主要有两个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 文章id</span><br><span class="line">articleId: &#123;type: String, required: true&#125;,</span><br><span class="line">// 访问时间</span><br><span class="line">createTime: &#123; type: Date, default: Date.now, required: true&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据量"><a href="#数据量" class="headerlink" title="数据量"></a>数据量</h5><p>目前数据量有1千多万，每日增长量10万左右。</p>
<h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>1.按天统计一段时间内总访问量；<br>2.按天统计一段时间内某个文章的访问量；<br>3.一段时间内访问量前20文章的信息及访问量；<br>4.按小时统计某一天的访问量；<br>5.按小时统计某一天某个文章的访问量。</p>
<h2 id="实现各个需求的具体方案"><a href="#实现各个需求的具体方案" class="headerlink" title="实现各个需求的具体方案"></a>实现各个需求的具体方案</h2><p>下面就几个产品需求来讲述下具体的实现方案。</p>
<h4 id="按天统计一段时间内总访问量"><a href="#按天统计一段时间内总访问量" class="headerlink" title="按天统计一段时间内总访问量"></a>按天统计一段时间内总访问量</h4><p>刚接到这个需求时，我便尝试着直接查accessArticle文档，指定一个月的时间，用find的方法（当时还不知道聚合查询），效率很低，大概要几秒钟，而且这还不包括运算统计，并且面对日益增多的庞大数据，效率简直就是恶梦，所以显然这种方式是不行的。因为日志产生过后已是历史，不会再被更新，如果做pv统计时每次都去重新做统计运算，等于在统计运算上做了重复劳动。经过一番尝试与考虑，决定每天对accessArticle文档进行统计，将统计结果按天存入另一个文档countHistory中。这样每天只增多一条记录，即使是10年也最多只有3660条，查询的效率就不是问题了。下面再详细说一下方案吧。<br>countHistory文档结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 该天日志的日期</span><br><span class="line">time: &#123;type: Date, required: true&#125;,</span><br><span class="line">// 访问量</span><br><span class="line">num: &#123; type: Number, required: true&#125;</span><br></pre></td></tr></table></figure>
<p>每天更新统计历史（伪代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exports.updateHistory = function()&#123;</span><br><span class="line">    async.auto(&#123;</span><br><span class="line">        getLast: function (callback)&#123;</span><br><span class="line">            // 计算或者是获取到要统计那天的日期</span><br><span class="line">        &#125;,</span><br><span class="line">        countAccess: [&#x27;getLast&#x27;,function(callback, results)&#123;</span><br><span class="line">            // 计算统计那天的pv</span><br><span class="line">        &#125;],</span><br><span class="line">        addHistory: [&#x27;countAccess&#x27;, function(callback, results)&#123;</span><br><span class="line">            // 插入countHistory</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;, function(err, results)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用node-schedule做类似linux下的crontab任务，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var schedule = require(&#x27;node-schedule&#x27;);</span><br><span class="line">schedule.scheduleJob(&#x27;0 2 * * *&#x27;, updateHistory); // 每天凌晨3：00统计前天访问日志</span><br></pre></td></tr></table></figure>
<p>查找某个时间段内的访问量（伪代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var query = &#123;</span><br><span class="line">	$gte: startDate,</span><br><span class="line">	$lte: endDate</span><br><span class="line">&#125;</span><br><span class="line">countHistory.find(query, &quot;num time&quot;, options, callback);</span><br></pre></td></tr></table></figure>
<p>这样查询出来的num数据便是startDate到endDate内每个time的pv了。</p>
<h4 id="聚合统计每天文章数据"><a href="#聚合统计每天文章数据" class="headerlink" title="聚合统计每天文章数据"></a>聚合统计每天文章数据</h4><p>接下来的需求是需要把某个文章的信息加上去，统计该文章的访问量。因为涉及到计算每天某个文章访问量的问题，我便想节省这个运算，把结果存入countHistory。这时便需要新建一个countArticle字段来存储结果，因为每天文章数很多，所以这个字段是数组类型，每个数组项是一个文章信息，数组项里只有一个属性及值，属性是文章id，值是该文章当天的访问量。所以这时countHistory的文档结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 该天日志的日期</span><br><span class="line">time: &#123;type: Date, required: true&#125;,</span><br><span class="line">// 访问量</span><br><span class="line">num: &#123; type: Number, required: true&#125;,</span><br><span class="line">// 文章统计</span><br><span class="line">countArticle: [</span><br><span class="line">        &#123;</span><br><span class="line">            _id: &#123;type: String&#125;, // 文章id</span><br><span class="line">            hotScore: &#123; type: Number&#125; // 当天该文章访问量</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>这时每天定时更新统计历史的代码便需要增加多文章的统计了，先看看完整的伪代码。<br>每天更新统计历史（伪代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">exports.updateHistory = function()&#123;</span><br><span class="line">    async.auto(&#123;</span><br><span class="line">        getLast: function (callback)&#123;</span><br><span class="line">            // 计算或者是获取到要统计那天的日期</span><br><span class="line">        &#125;,</span><br><span class="line">        countAccess: [&#x27;getLast&#x27;,function(callback, results)&#123;</span><br><span class="line">            // 计算统计那天的pv</span><br><span class="line">        &#125;],</span><br><span class="line">		getAccess: [&#x27;getLast&#x27;, function (cb, results) &#123;</span><br><span class="line">			// 文章统计</span><br><span class="line">		&#125;],</span><br><span class="line">        addHistory: [&#x27;countAccess&#x27;, function(callback, results)&#123;</span><br><span class="line">            // 插入countHistory</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;, function(err, results)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体的文章统计便需要下面的聚合查询来做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accessArticle.aggregate([</span><br><span class="line">	&#123;$match: &#123;createTime: results.setTimeQuery&#125;&#125;, // 匹配条件。必需放在最前面才有效</span><br><span class="line">	&#123;$group : &#123;_id : &quot;$articleId&quot;, hotScore : &#123;$sum : 1&#125;&#125;&#125;// 将集合中的文档分组，可用于统计结果</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>$match跟find查询的query参数一样，在这里是先把某天的数据记录取出来。<br>$group是分组聚合，将同了articleId的记录合并为一条记录，并且新增一个hotScore字段，值为合并的记录数之和。<br>之后再把结果放在countArticle字段里，再插入到countHistory文档中，便完成了每日统计日志的任务。</p>
<h4 id="按天统计一段时间内某个文章的访问量"><a href="#按天统计一段时间内某个文章的访问量" class="headerlink" title="按天统计一段时间内某个文章的访问量"></a>按天统计一段时间内某个文章的访问量</h4><p>现在countArticle字段里已经有文章的pv信息，只要我们能够取出某个文章id的数据，就能实现这个需求。恰好mongodb聚合查询里$unwind,$project,$group可以满足我们的需求。<br>完整的聚合查询为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">countHistory.aggregate(</span><br><span class="line">	[</span><br><span class="line">		&#123;$match: query&#125;,</span><br><span class="line">		&#123;$unwind: &quot;$countArticle&quot;&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			$project: &#123;</span><br><span class="line">				countArticle: 1,</span><br><span class="line">				time: &#123; $dateToString: &#123; format: &quot;%Y-%m-%d&quot;, date: &quot;$time&quot; &#125; &#125;,</span><br><span class="line">				articleId: &quot;$countArticle._id&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;$match: &#123;articleId: articleId&#125;&#125;,</span><br><span class="line">		&#123;$group : &#123;_id : &quot;$time&quot;, hotScore : &#123;$sum &quot;$countArticle.hotScore&quot;&#125;&#125;&#125;,</span><br><span class="line">		&#123;$sort: &#123;_id: 1&#125;&#125;</span><br><span class="line">	]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>下面来具体分析一下这个聚合查询。<br>$match跟find查询的query参数一样，在这里是先把符合时间条件的记录取出来。<br>$unwind能把数组字段里的每一项都拆分出来，再构建新的记录。<br>如果2016-03-20这天的记录是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	time: &#x27;2016-03-20 15:59:59.999Z&#x27;,</span><br><span class="line">	num:2,</span><br><span class="line">	countArticle: [</span><br><span class="line">		&#123;_id: 1, hotScore: 10&#125;,</span><br><span class="line">		&#123;_id: 2, hotScore: 11&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 经过$unwind之后，数据会变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	time: &#x27;2016-03-20 15:59:59.999Z&#x27;,</span><br><span class="line">	num:2,</span><br><span class="line">	countArticle: [</span><br><span class="line">		&#123;_id: 1, hotScore: 10&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	time: &#x27;2016-03-20 15:59:59.999Z&#x27;,</span><br><span class="line">	num:2,</span><br><span class="line">	countArticle: [</span><br><span class="line">		&#123;_id: 2, hotScore: 11&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再利用mongodb聚合查询的管道特性（即每次查询的结果都会作为下一次聚合的输入），再对查询的结果进行$project聚合，它可以修改文档的结构，将数组里的文章id提上一级。并且用$dateToString把时间格式化，具体显示到天。即上述演示数据结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	_id: 1，</span><br><span class="line">	time: &#x27;2016-03-20&#x27;,</span><br><span class="line">	countArticle: [</span><br><span class="line">		&#123;_id: 1, hotScore: 10&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	_id: 2,</span><br><span class="line">	time: &#x27;2016-03-20&#x27;,</span><br><span class="line">	num:2,</span><br><span class="line">	countArticle: [</span><br><span class="line">		&#123;_id: 2, hotScore: 11&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再用$match根据文章id过滤掉不需要的文章。<br>$group是一个分组的聚合操作，将同一天的记录归入同一组，并用$sum把文章当天访问量累加起来，操作之后的结果便是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	_id: &#x27;2016-03-20&#x27;,</span><br><span class="line">	hotScore: 21</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后$sort运算符可以将数据以time字段排序，这样传到前端将是比较整洁的结果。</p>
<h4 id="一段时间内访问量前20文章的信息及访问量"><a href="#一段时间内访问量前20文章的信息及访问量" class="headerlink" title="一段时间内访问量前20文章的信息及访问量"></a>一段时间内访问量前20文章的信息及访问量</h4><p>理解了上一个需求的做法，那这个需求也就迎刃而解了。先来看看完整的实现聚合查询代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">countHistory.aggregate(</span><br><span class="line">[</span><br><span class="line">	&#123;$match: query&#125;,</span><br><span class="line">	&#123;$unwind: &quot;$countArticle&quot;&#125;, // 将文档中的countArticle数组类型字段拆分成多条，每条包含数组中的一个值。</span><br><span class="line">	&#123;</span><br><span class="line">		$group : &#123;</span><br><span class="line">			_id : &quot;$countArticle._id&quot;,</span><br><span class="line">			hotScore : &#123;$sum : &quot;$countArticle.hotScore&quot;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, // 将集合中的文档分组，可用于统计结果</span><br><span class="line">	&#123;$sort: &#123;hotScore: -1&#125;&#125;, // 热度降序排序</span><br><span class="line">	&#123;$limit: 20&#125;</span><br><span class="line">]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>有了上一个需求的基础，相信大家看到这段代码的注释也能够理解各个管道运算了。这里我就简述一下思路吧。<br>先取出符合时间条件的数据，分解数组字段countArticle，暴露其每个子项，然后再按其中的文章id分组，并且计算各个文章的访问量，最后依照访问量排序，取出其中的前20个，便达到需求的目的了。</p>
<h4 id="按小时统计某一天的访问量"><a href="#按小时统计某一天的访问量" class="headerlink" title="按小时统计某一天的访问量"></a>按小时统计某一天的访问量</h4><p>因为前面的countHistory只存储了以天为维度的统计数据，对于这种按小时来统计的，便无法满足。虽然可以再存储这些运算结果，但成本比较大，考虑到mongodb专门设计了一些运算符来解决这个问题，并且效率不错，便尝试着运用它来实现这个需求。<br>mongodb有专门为这种统计方式设计了一些运算符，这里我便用到了其中的$hour。它能够按小时来对时间进行分组统计。先来看看完整的聚合查询代码吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">accessArticle.aggregate([</span><br><span class="line">	&#123;$match: query &#125;,</span><br><span class="line">	&#123;$group: &#123;</span><br><span class="line">		_id: &#123;</span><br><span class="line">			&quot;$hour&quot;: &quot;$createTime&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		pv: &#123;$sum: 1&#125;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>这样查询出来的数据格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;_id: 0, pv:100&#125;,</span><br><span class="line">	&#123;_id: 1, pv:200&#125;,</span><br><span class="line">	···</span><br><span class="line">	&#123;_id: 23, pv:100&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>_id的0到23对应每天的24小时，pv为统计的结果值。</p>
<p>本来觉得的相当简单的操作，但到了测试那天，才发现了另一个可怕的问题。</p>
<p>当天下午4点多的时候，我测试了在当天按小时统计数据，却意外地发现当天24小时都有数据。简直是见鬼了。之后经过了无数遍代码逻辑，发现都没问题，但是出来的数据却是错误的。曾经还一度怀疑是不是mongodb的bug。但我还是决定再调试调试，先把$match之后的数据再$project和$dateToString对时间格式化，具体到小时。这才发现，出来的数据包括了前一天的！！！难道真是mongodb的bug？还是我时间存错了？再看看mongdb的时间数据，发现了它是以ISODate的形式存的，再搜索了解ISODate，发现mongodb是以UTC格式存储时间，而这种时间比CST（中国标准时间）慢8个小时。因此，我看到$dateToString格式化的时间，其实是UTC的时间，所以才会出现前一天的数据。所以$hour是按UTC的时间标准来的，我们获取到之后，还要对其进行加工，做法是加上8小时，并且以24小时制来计算，便能得到正确的结果。我的做法是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// results.getAccess为$hour聚合的结果</span><br><span class="line">// UTC转CST</span><br><span class="line">_.each(results.getAccess, function (item) &#123;</span><br><span class="line">	item._id = parseInt(item._id, 10)+8;</span><br><span class="line">	if (item._id &gt;= 24) &#123;</span><br><span class="line">		item._id = item._id - 24;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="按小时统计某一天某个文章的访问量"><a href="#按小时统计某一天某个文章的访问量" class="headerlink" title="按小时统计某一天某个文章的访问量"></a>按小时统计某一天某个文章的访问量</h4><p>与上一个需求类似，只要在$match条件里加多一个过滤掉不符合要求的文章id即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过学习mongodb的聚合查询，更加了解到它的强大。经过这番需求的实现及聚合查询的运用，给我印象最深刻的是聚合查询的管道特性，它十分的方便，并一次聚合的结果可以作为下一次运算的输入，是一个特别棒的功能，可以实现更为复杂地运算或查询。所以聚合查询的运算符虽然放在数组里，但它的顺序是有规矩的。$match放在靠后位置查询不出结果也是我入的第一个坑。<br>还有遇到另一个现在还没有找到答案的问题，$filter聚合用于部署在阿里云上面的服务器的mongodb3.2.3版本里报错，信息是不支持该运算符。但我用同样的命令在测试环境里相同版本的mongodb却能够正常执行。这真是个奇葩的问题。希望能有解决此问题的大侠出现。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/43.html">linux命令转义</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/linux/">linux</a></span><div class="content"><p>今天在执行mongodb以下导出命令时，linux问题提示一些奇怪的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoexport --db test --collection col --out col.json --authenticationDatabase test --password abc123!!## --username test</span><br></pre></td></tr></table></figure>
<p>经检查，用户名密码都是正确的。命令的使用也在测试环境上通过了。经过一次又一次的比较，发现唯一的区别在于密码有特殊字符。经过一番搜索，才发现原来linux命令如果要使用特殊字符，如!,#等，都需要加上转义字符“\”。所以，上面的命令应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoexport --db test --collection col --out col.json --authenticationDatabase test --password abc123\!\!\#\# --username test</span><br></pre></td></tr></table></figure>
<p>呜呜~这就是菜鸟程序员整天纠结的小问题。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/42.html">介绍mongodb数据查询运算符</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mongodb/">mongodb</a></span><div class="content"><p>今天来介绍下mongodb数据查询的几个运算符，它们都相对好理解。</p>
<h2 id="eq"><a href="#eq" class="headerlink" title="$eq"></a>$eq</h2><p>简述：匹配字段某值或者匹配数组字段内某子项的值来查询<br>记忆： equal<br>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &lt;field&gt;: &#123; $eq: &lt;value&gt; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>示例：<br>inventory表的原始数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ] &#125;</span><br><span class="line">&#123; _id: 2, item: &#123; name: &quot;cd&quot;, code: &quot;123&quot; &#125;, qty: 20, tags: [ &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 3, item: &#123; name: &quot;ij&quot;, code: &quot;456&quot; &#125;, qty: 25, tags: [ &quot;A&quot;, &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;A&quot; ] &#125;</span><br><span class="line">&#123; _id: 5, item: &#123; name: &quot;mn&quot;, code: &quot;000&quot; &#125;, qty: 20, tags: [ [ &quot;A&quot;, &quot;B&quot; ], &quot;C&quot; ] &#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-匹配值"><a href="#1-匹配值" class="headerlink" title="1.匹配值"></a>1.匹配值</h5><p>具体代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; qty: &#123; $eq: 20 &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; qty: 20 &#125; )</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 2, item: &#123; name: &quot;cd&quot;, code: &quot;123&quot; &#125;, qty: 20, tags: [ &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 5, item: &#123; name: &quot;mn&quot;, code: &quot;000&quot; &#125;, qty: 20, tags: [ [ &quot;A&quot;, &quot;B&quot; ], &quot;C&quot; ] &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-匹配数组字段子项的值"><a href="#2-匹配数组字段子项的值" class="headerlink" title="2.匹配数组字段子项的值"></a>2.匹配数组字段子项的值</h5><p>具体代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; tags: &#123; $eq: &quot;B&quot; &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ] &#125;</span><br><span class="line">&#123; _id: 2, item: &#123; name: &quot;cd&quot;, code: &quot;123&quot; &#125;, qty: 20, tags: [ &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 3, item: &#123; name: &quot;ij&quot;, code: &quot;456&quot; &#125;, qty: 25, tags: [ &quot;A&quot;, &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;A&quot; ] &#125;</span><br></pre></td></tr></table></figure>

<p>小结：$eq匹配值等价于直接匹配值，其主要使用点还是在于匹配数组字段子项的值。</p>
<h2 id="gt-gte-lt-lte"><a href="#gt-gte-lt-lte" class="headerlink" title="$gt, $gte, $lt, $lte"></a>$gt, $gte, $lt, $lte</h2><p>这四个运算符的用法很相似，只要知道一个，其它都可以依此类推，只要知道：<br>$gt表示匹配字段某值大于指定值;<br>$gte表示匹配字段某值大于等于指定值;<br>$lt表示匹配字段某值小于指定值;<br>$lte表示匹配字段某值小于等于指定值;</p>
<p>下面用$gt来进行详细说明。<br>简述：匹配字段某值大于指定值<br>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;field: &#123;$gt: value&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>示例：<br>inventory表的原始数据<br>同$eq的inventory数据。</p>
<p>具体代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; qty: &#123; $gt: 20 &#125; &#125; )</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 3, item: &#123; name: &quot;ij&quot;, code: &quot;456&quot; &#125;, qty: 25, tags: [ &quot;A&quot;, &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;A&quot; ] &#125;</span><br></pre></td></tr></table></figure>

<p>注：在这几个运算符中，可对js的date类型值进行直接比较。</p>
<h2 id="ne"><a href="#ne" class="headerlink" title="$ne"></a>$ne</h2><p>简述：匹配字段某值不为指定值<br>记忆： not equal<br>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;field: &#123;$ne: value&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>示例：<br>inventory表的原始数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ] &#125;</span><br><span class="line">&#123; _id: 2, item: &#123; name: &quot;cd&quot; &#125;, qty: 20, tags: [ &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 3, item: &#123; name: &quot;ij&quot; &#125;, qty: 25, tags: [ &quot;A&quot;, &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;A&quot; ] &#125;</span><br><span class="line">&#123; _id: 5, item: &#123; name: &quot;mn&quot;, code: &quot;000&quot; &#125;, qty: 20, tags: [ [ &quot;A&quot;, &quot;B&quot; ], &quot;C&quot; ] &#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-不等于具体值"><a href="#1-不等于具体值" class="headerlink" title="1. 不等于具体值"></a>1. 不等于具体值</h5><p>具体代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; qty: &#123; $ne: 20 &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ] &#125;</span><br><span class="line">&#123; _id: 3, item: &#123; name: &quot;ij&quot; &#125;, qty: 25, tags: [ &quot;A&quot;, &quot;B&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;A&quot; ] &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-没有某字段"><a href="#2-没有某字段" class="headerlink" title="2.没有某字段"></a>2.没有某字段</h4><p>具体代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; &quot;item.code&quot;: &#123; $ne: null &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;A&quot; ] &#125;</span><br><span class="line">&#123; _id: 5, item: &#123; name: &quot;mn&quot;, code: &quot;000&quot; &#125;, qty: 20, tags: [ [ &quot;A&quot;, &quot;B&quot; ], &quot;C&quot; ] &#125;</span><br></pre></td></tr></table></figure>

<h2 id="in-nin"><a href="#in-nin" class="headerlink" title="$in, $nin"></a>$in, $nin</h2><p>简述：与$eq,$ne相似，区别在于指定值是数组，即一些数值，可以为把要比较的字段数值与1个以上的数据进行比较。<br>下面用$in来举例<br>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; field: &#123; $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>示例：<br>inventory表的原始数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;ab&quot;, &quot;abc&quot;, &quot;123&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;abc&quot; ] &#125;</span><br><span class="line">&#123; _id: 5, item: &#123; name: &quot;mn&quot;, code: &quot;000&quot; &#125;, qty: 20, tags: [ [ &quot;A&quot;, &quot;B&quot; ], &quot;C&quot; ] &#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-1个以上常规值匹配"><a href="#1-1个以上常规值匹配" class="headerlink" title="1. 1个以上常规值匹配"></a>1. 1个以上常规值匹配</h5><p>具体代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; tags: &#123; $in: [&#x27;abc&#x27;, &#x27;123&#x27;] &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;ab&quot;, &quot;abc&quot;, &quot;123&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;abc&quot; ] &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-正规表达式匹配"><a href="#2-正规表达式匹配" class="headerlink" title="2.正规表达式匹配"></a>2.正规表达式匹配</h4><p>具体代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; tags: &#123; $in: [/^ab/, /^12/] &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; _id: 1, item: &#123; name: &quot;ab&quot;, code: &quot;123&quot; &#125;, qty: 15, tags: [ &quot;ab&quot;, &quot;abc&quot;, &quot;123&quot; ] &#125;</span><br><span class="line">&#123; _id: 4, item: &#123; name: &quot;xy&quot;, code: &quot;456&quot; &#125;, qty: 30, tags: [ &quot;B&quot;, &quot;abc&quot; ] &#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/41.html">开启HTTP/2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/qianlizhixing/">qianlizhixing</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/nginx/">nginx</a></span><div class="content"><p>好久前就听说Http2.0，听说它比1版本有性能上的提升并且还有主动把请求推送到客户端的功能。因为开启http2.0需要先实现https，并且nginx版本需要在1.9以上，刚好本站满足这样的要求。今天终于压制不住好奇，搞了一下本站对http2.0的支持。</p>
<h2 id="关于HTTP-x2F-2及其优点"><a href="#关于HTTP-x2F-2及其优点" class="headerlink" title="关于HTTP&#x2F;2及其优点"></a>关于HTTP&#x2F;2及其优点</h2><h5 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h5><p>HTTP&#x2F;2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP&#x2F;2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>1、采用二进制格式传输数据，而非文本格式，二进制格式在协议的解析和优化扩展上带来更多的优势和可能；<br>2、对消息头进行压缩传输，能够节省消息头占用的网络的流量，而 http1.1 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源，头压缩能够很好的解决该问题；<br>3、多路复用，就是多个请求都是通过一个 TCP 连接并发完成，http1.1 虽然通过pipeline也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 http2.0做到了真正的并发请求，同时，流还支持优先级和流量控制；<br>4、服务器推送，服务端能够更快的把资源推送给客户端，例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求，当客户端需要的时候，它已经在客户端了</p>
<h2 id="HTTP-x2F-2站点的优势"><a href="#HTTP-x2F-2站点的优势" class="headerlink" title="HTTP&#x2F;2站点的优势"></a>HTTP&#x2F;2站点的优势</h2><p>1，提升网站访问速度；<br>2，降低服务器压力;<br>3，部分替代异步加载的使用；<br>4，保护网站安全。</p>
<h2 id="如何开启HTTP-x2F-2"><a href="#如何开启HTTP-x2F-2" class="headerlink" title="如何开启HTTP&#x2F;2"></a>如何开启HTTP&#x2F;2</h2><p>哇，看到HTTP&#x2F;2有这么多优点，真想马上就换上。下面为大家讲述下本站是如何利用nginx开启HTTP&#x2F;2的。</p>
<h5 id="nginx加入http-v2-module模块"><a href="#nginx加入http-v2-module模块" class="headerlink" title="nginx加入http_v2_module模块"></a>nginx加入http_v2_module模块</h5><p>nginx版本需要在1.9以上，并且需要有http_v2_module模块，如果没有，请重新编译。本站有<a target="_blank" rel="noopener" href="https://www.yangrunwei.com/a/34.html">重新编译nginx</a>的文章。<br>具体实现的话，只需要把相应代码修改成以下即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/nginx --with-http_ssl_module --with-http_v2_module</span><br></pre></td></tr></table></figure>
<h5 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h5><p>需要修改的配置很简单，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在之前的ssl后加上http2，重新启动nginx即可。</p>
<h5 id="验证是否开启"><a href="#验证是否开启" class="headerlink" title="验证是否开启"></a>验证是否开启</h5><p>在nginx日志中输出$request变量，tail -f 的形式看下nginx的日志，然后访问站点，如果输出有HTTP&#x2F;2.0即表示开启成功。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP/2">HTTP&#x2F;2</a><br><a target="_blank" rel="noopener" href="http://picasso250.github.io/2015/12/03/nignx-http2-cipher.html">Nginx HTTP 2 的编译和配置</a><br><a target="_blank" rel="noopener" href="http://www.szfangwei.cn/news/2886.html">HTTP2.0来了，看看哪些优点值得你更换</a><br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_v2_module.html">Module ngx_http_v2_module</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/40.html">mongodb获取相邻数据</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/qianlizhixing/">qianlizhixing</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mongodb/">mongodb</a></span><div class="content"><p>今天给本站文章页面增加了文章的上一篇与下一篇的链接。原理相对简单，主要是利用文章的分页来实现的。下面通过代码与讲解来简单分析下。</p>
<h2 id="获取上一篇"><a href="#获取上一篇" class="headerlink" title="获取上一篇"></a>获取上一篇</h2><p>取出文章表中创建时间小于当前数据的创建时间的，注意要按发布时间的倒序排列，然后取第一个，便是所要的当前文章的上一篇。具体代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article.find(&#123;createTime: &#123;$lt: currentArticle.createTime&#125;&#125;, &#x27;_id&#x27;, &#123;skip: 0, limit: 1, sort: &#123;createTime: &#x27;desc&#x27;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取下一篇"><a href="#获取下一篇" class="headerlink" title="获取下一篇"></a>获取下一篇</h2><p>如果理解了上一篇的取法，那下一篇也自然懂得了。<br>取出文章表中创建时间大于当前数据的创建时间的，注意要按发布时间的正序排列，然后取第一个，便是所要的当前文章的下一篇。具体代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article.find(&#123;createTime: &#123;$gt: currentArticle.createTime&#125;&#125;, &#x27;_id&#x27;, &#123;skip: 0, limit: 1, sort: &#123;createTime: &#x27;asc&#x27;&#125;&#125;);</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/39.html">PC及移动端网页中嵌入视频</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webFE/">webFE</a></span><div class="content"><p>UEditor编辑器提供了嵌入视频的功能，实际上是往html里嵌入embed元素。这是H5新标签，目前有兼容问题。目前最兼容的方案还是使用iframe来实现。然而允许用户或者运营者提交iframe，是十分不安全的。所以，我们折衷地在输出内容时，将embed用iframe代替，这样在未来浏览器都升级后可以直接使用embed，也可以保证现在可以正常运行。</p>
<h2 id="拿腾讯视频举栗子"><a href="#拿腾讯视频举栗子" class="headerlink" title="拿腾讯视频举栗子"></a>拿腾讯视频举栗子</h2><h5 id="1-首先获取到视频源，我们取embed里的src值，如图："><a href="#1-首先获取到视频源，我们取embed里的src值，如图：" class="headerlink" title="1.首先获取到视频源，我们取embed里的src值，如图："></a>1.首先获取到视频源，我们取embed里的src值，如图：</h5><p><img src="https://img.yangrunwei.com/article-img/20160308/cbb72b84-2f0c-44d3-b4fd-87c38faa9a34--39-1.png" alt="获取腾讯视频源" title="获取腾讯视频源"></p>
<h5 id="2-将值填入UEditor编辑器的视频上传组件中，如图："><a href="#2-将值填入UEditor编辑器的视频上传组件中，如图：" class="headerlink" title="2.将值填入UEditor编辑器的视频上传组件中，如图："></a>2.将值填入UEditor编辑器的视频上传组件中，如图：</h5><p><img src="https://img.yangrunwei.com/article-img/20160308/2da9216a-a622-4a5b-bebc-f1fa4b86d68c--39-2.png" alt="UEditor上传视频" title="UEditor上传视频"></p>
<h5 id="3-输出时将ebmed替换成iframe"><a href="#3-输出时将ebmed替换成iframe" class="headerlink" title="3.输出时将ebmed替换成iframe"></a>3.输出时将ebmed替换成iframe</h5><p>网站用jade模块，读者也可以在前端进行替换，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = content.replace(/&lt;embed(.*?) src=&quot;http:\/\/static\.video\.qq\.com\/(.*?)\.swf(.*?)&quot;&gt;/gmi, &#x27;&lt;iframe frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;200&quot; src=&quot;http://v.qq.com/iframe/player.html?$3&amp;tiny=0&quot; allowfullscreen&gt;&lt;/iframe&gt;&#x27;)</span><br></pre></td></tr></table></figure>
<p>之所以能够将embed替换成iframe，是因为腾讯视频的swf源和iframe源基本只有根域名的差别，知道一个可以推导成另一个，如<br>swf源为：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://static.video.qq.com/TPout.swf?vid=x00193363qx&amp;auto=0">http://static.video.qq.com/TPout.swf?vid=x00193363qx&amp;auto=0</a></p>
</blockquote>
<p>那iframe源则为：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://v.qq.com/iframe/player.html?vid=x00193363qx&amp;tiny=0&amp;auto=0">http://v.qq.com/iframe/player.html?vid=x00193363qx&amp;tiny=0&amp;auto=0</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/37.html">谈谈自己平时使用的页面布局方法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webFE/">webFE</a></span><div class="content"><h2 id="position相对布局"><a href="#position相对布局" class="headerlink" title="position相对布局"></a>position相对布局</h2><p>这种布局一般使用在一个元素相对于父元素的定位，如右下角，中间等。首先把父元素，即布局元素要参考的元素设置position为relative，然后自身设置absolute，这样就可以达到相对布局的效果了。这里会有一种特殊情况，即需要定位在中间，即元素是垂直且水平居中，首先设置定位元素top: 50%; right: 50%; 这时元素并不是被定位在参考元素的中间，这时要把需要定位的元素设置宽高，然后margin-left: 宽度一半;margin-top:高度一半;这样就能达到定位在中间的效果了。具体看下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .wrap &#123;</span><br><span class="line">      border: 1px solid #aaaaaa;</span><br><span class="line">      background-color: #eeeeee;</span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 300px;</span><br><span class="line">      position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .k1 &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      bottom: 0;</span><br><span class="line">      right: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .k2 &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      width: 20px;</span><br><span class="line">      height: 20px;</span><br><span class="line">      left: 50%;</span><br><span class="line">      top: 50%;</span><br><span class="line">      margin-left: -10px;</span><br><span class="line">      margin-top: -10px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;k1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;k2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="inline-block大法"><a href="#inline-block大法" class="headerlink" title="inline-block大法"></a>inline-block大法</h2><p>inline-block可以使行内元素，如a，span，i等，可以设置宽高，也可以使div在同一行排列起来。缺点是元素间会有间隔，可以在父元素上设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-size: 0;</span><br><span class="line">-webkit-text-size-adjust:none;</span><br></pre></td></tr></table></figure>
<p>来消除这个间隔。</p>
<h2 id="vertical-align-middle"><a href="#vertical-align-middle" class="headerlink" title="vertical-align: middle"></a>vertical-align: middle</h2><p>这个样式我主要是使用在把图片与文字居中显示。如果我们要把img与span里的文字居中显示。只需要把img与span设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display: inline-block;</span><br><span class="line">vertical-align: middle;</span><br></pre></td></tr></table></figure>
<p>checkbox与文字居中也可以用这种方式来实现。</p>
<h2 id="兼容到ie8及以上的页面布局"><a href="#兼容到ie8及以上的页面布局" class="headerlink" title="兼容到ie8及以上的页面布局"></a>兼容到ie8及以上的页面布局</h2><p>最近需要做兼容到ie8及以上的页面，而且没有使用UI框架，全是需要自己用css来构建。通过参考一些大的门户网站（因为这些网站面向所有群体，所以兼容肯定做得不赖，虽然有些比较丑），发现了以下的布局方法。<br>接下来通过代码来演示</p>
<h5 id="具体实现代码如下："><a href="#具体实现代码如下：" class="headerlink" title="具体实现代码如下："></a>具体实现代码如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .wrap &#123;</span><br><span class="line">      width: 610px;</span><br><span class="line">    &#125;</span><br><span class="line">    .clearfix:after &#123;</span><br><span class="line">      content: &quot;.&quot;;</span><br><span class="line">      display: block;</span><br><span class="line">      height: 0;</span><br><span class="line">      clear: both;</span><br><span class="line">      visibility: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .f-l &#123;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .item &#123;</span><br><span class="line">      border: 1px solid #aaaaaa;</span><br><span class="line">      background-color: #eeeeee;</span><br><span class="line">      width: 200px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      line-height: 200px;</span><br><span class="line">      text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;clearfix wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item f-l&quot;&gt;块1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item f-l&quot;&gt;块2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item f-l&quot; style=&quot;height: 300px&quot;&gt;块3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item f-l&quot;  style=&quot;height: 300px&quot;&gt;块4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item f-l&quot;&gt;块5&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="https://img.yangrunwei.com/article-img/20160303/dff605d5-dc9c-400e-8be5-0963dce23554--37-1.png" alt="布局效果图" title="布局效果图"></p>
<h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>模拟表格的方式来对元素进行布局排列。因为表格的样式更符合布局的习惯，或者说更符合一些设计的需求。但因为表格元素有特定的语义，所以不建议直接使用表格元素布局，但display可以让我们满足表格形式的布局。具体看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .wrap &#123;</span><br><span class="line">      width: 610px;</span><br><span class="line">      display: table;</span><br><span class="line">    &#125;</span><br><span class="line">    .row &#123;</span><br><span class="line">      display: table-row;</span><br><span class="line">    &#125;</span><br><span class="line">    .item &#123;</span><br><span class="line">      border: 1px solid #aaaaaa;</span><br><span class="line">      background-color: #eeeeee;</span><br><span class="line">      width: 200px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      line-height: 200px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      display: table-cell;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;item f-l&quot;&gt;块1&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;item f-l&quot;&gt;块2&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;item f-l&quot;&gt;块3&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>注：这种布局的特点时，在设置元素宽高的时候，可以不包括border。这也使得有时候更方便计算。</p>
<h2 id="页面布局资源"><a href="#页面布局资源" class="headerlink" title="页面布局资源"></a>页面布局资源</h2><p><a target="_blank" rel="noopener" href="http://www.w3cplus.com/css/centering-css-complete-guide.html">CSS居中完整指南</a><br><a target="_blank" rel="noopener" href="http://www.w3cplus.com/css/elements-horizontally-center-with-css.html">六种实现元素水平居中</a><br><a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">去除inline-block元素间间距的N种方法</a><br><a target="_blank" rel="noopener" href="http://www.divcss5.com/css-texiao/texiao571.shtml">CSS3圆角圆边 支持IE6-IE8浏览器</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/36.html">.gitignore规则不生效的解决办法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><p>.gitignore是配置git的提交和更新规则的文件，比如可以配置提交时排除某些文件。但如果要对之前已经被提交到本地的文件再配置排除，那是行不通的。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先配置好.gitignore，增加需要的配置项；<br>然后通过清除本地git仓库的缓存来解决，执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br></pre></td></tr></table></figure>
<p>再执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/a/34.html">重新编译nginx</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-02-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tech/">tech</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/nginx/">nginx</a></span><div class="content"><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h5 id="找到之前nginx的安装包"><a href="#找到之前nginx的安装包" class="headerlink" title="找到之前nginx的安装包"></a>找到之前nginx的安装包</h5><p>如果之前有备份，则用这个备份的包。如果没有，则需要知道自己nginx的版本，然后到<a target="_blank" rel="noopener" href="http://nginx.org/">官网</a>下载此版本的安装包。</p>
<h5 id="更新openssl"><a href="#更新openssl" class="headerlink" title="更新openssl"></a>更新openssl</h5><p>为了防止出现以下错误，最好更新openssl，如图所示<br><img src="https://img.yangrunwei.com/article-img/20160226/b04bafc4-54ca-43c9-acc0-6cd568935f0a--34-1.jpg" alt="openssl_error" title="openssl_error"></p>
<p>以ubuntu为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h5 id="备份目前的nginx"><a href="#备份目前的nginx" class="headerlink" title="备份目前的nginx"></a>备份目前的nginx</h5><p>为了安全起见，最好做个备份。<br>假如nginx放在&#x2F;opt目录下，则执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /opt/nginx/sbin/nginx /opt/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>


<h2 id="重新编译nginx"><a href="#重新编译nginx" class="headerlink" title="重新编译nginx"></a>重新编译nginx</h2><p>假如我们安装包放在家目录下的Soft目录里，版本是1.9.6，则依次执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Soft</span><br><span class="line">tar xvzf nginx-1.9.6.tar.gz</span><br><span class="line">cd nginx-1.9.6</span><br><span class="line">./configure --prefix=/opt/nginx --with-http_ssl_module</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>注：这里需要注意的是，不能用make install代替，因为make install是覆盖安装。</p>
<h2 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h2><p>此时当前目录下的objs里就有一个新的nginx文档，把这个新nginx覆盖掉目前的nginx就可以了。但是现在的nginx正在运行，怎样才能保证平滑升级呢？</p>
<h5 id="覆盖旧的nginx"><a href="#覆盖旧的nginx" class="headerlink" title="覆盖旧的nginx"></a>覆盖旧的nginx</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -rfp objs/nginx /opt/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<h5 id="测试新版本nginx是否正常"><a href="#测试新版本nginx是否正常" class="headerlink" title="测试新版本nginx是否正常"></a>测试新版本nginx是否正常</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nginx/sbin</span><br><span class="line">sudo ./nginx -t</span><br></pre></td></tr></table></figure>

<h5 id="平滑升级nginx"><a href="#平滑升级nginx" class="headerlink" title="平滑升级nginx"></a>平滑升级nginx</h5><h6 id="1-启动新nginx版本，新旧共存"><a href="#1-启动新nginx版本，新旧共存" class="headerlink" title="1.启动新nginx版本，新旧共存"></a>1.启动新nginx版本，新旧共存</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill -USR2 `cat /opt/nginx/logs/nginx.pid` </span><br></pre></td></tr></table></figure>
<p>注：旧版本Nginx的pid变为oldbin，这是旧版本和新版本的nginx同时运行，过一段时间等就nginx处理完用户请求后，执行下面操作</p>
<h6 id="2-平缓停止worker-process"><a href="#2-平缓停止worker-process" class="headerlink" title="2.平缓停止worker process"></a>2.平缓停止worker process</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s WINCH `cat /opt/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>

<h6 id="3-关闭旧版nginx"><a href="#3-关闭旧版nginx" class="headerlink" title="3.关闭旧版nginx"></a>3.关闭旧版nginx</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s QUIT `cat /opt/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>

<h5 id="验证nginx是否升级成功"><a href="#验证nginx是否升级成功" class="headerlink" title="验证nginx是否升级成功"></a>验证nginx是否升级成功</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure>
<p>出现如下图结果则表示重新编译成功<br><img src="https://img.yangrunwei.com/article-img/20160226/96f9ca7d-37b4-42ca-a3e0-c0634a8830d6--34-2.png" alt="nginw-v" title="nginw-v"></p>
<h2 id="若新版nginx有异常，需要回滚到旧版"><a href="#若新版nginx有异常，需要回滚到旧版" class="headerlink" title="若新版nginx有异常，需要回滚到旧版"></a>若新版nginx有异常，需要回滚到旧版</h2><p>在旧版进程还在的时候，执行如下命令</p>
<h6 id="1、不加载配置启用旧版进程，重新接收请求"><a href="#1、不加载配置启用旧版进程，重新接收请求" class="headerlink" title="1、不加载配置启用旧版进程，重新接收请求"></a>1、不加载配置启用旧版进程，重新接收请求</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s HUP `cat /opt/nginx/logs/nginx.oldbin`</span><br></pre></td></tr></table></figure>
<h6 id="2、关闭新版nginx进程"><a href="#2、关闭新版nginx进程" class="headerlink" title="2、关闭新版nginx进程"></a>2、关闭新版nginx进程</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s QUIT `cat /opt/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>


<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果升级后出现改变nginx配置文件不生效的话，可以尝试停止nginx再启动。请看<a target="_blank" rel="noopener" href="https://www.yangrunwei.com/a/33.html">停止及启动nginx方法</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By 杨润炜</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>